<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="世间万物皆空。唯其空，便能包容万物。">
<meta property="og:type" content="website">
<meta property="og:title" content="永恒之道">
<meta property="og:url" content="http://cjoop.top/index.html">
<meta property="og:site_name" content="永恒之道">
<meta property="og:description" content="世间万物皆空。唯其空，便能包容万物。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="永恒之道">
<meta name="twitter:description" content="世间万物皆空。唯其空，便能包容万物。">






  <link rel="canonical" href="http://cjoop.top/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>永恒之道</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">永恒之道</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/10/20/Redis-Cluster-Tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/20/Redis-Cluster-Tutorial/" itemprop="url">
                  Redis cluster tutorial
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-10-20 21:30:26" itemprop="dateCreated datePublished" datetime="2016-10-20T21:30:26+08:00">2016-10-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/10/20/Redis-Cluster-Tutorial/" class="leancloud_visitors" data-flag-title="Redis cluster tutorial">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文档是对Redis Cluster的简单介绍，不会使用复杂的分布式系统概念来去理解。它只是提供了从用户角度来如果如何搭建集群，测试以及使用的方法，没有完全覆盖<a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis Cluster specification</a>内容。</p>
<p>所以本教程试图提供给最终用户一个简单的关于集群和一致性特征的描述.</p>
<p>注意，本教程必须使用Redis 3.0版本或者更高的版本。</p>
<p>如果你计划部署一个重要的Redis Cluster,推荐阅读正式的规范文档，即使载不严格的要求下。不管怎样从这篇文档开始是一个很好的主意，玩一会儿Redis Cluster后，在去阅读规范。</p>
<h2 id="Redis-Cluster-101"><a href="#Redis-Cluster-101" class="headerlink" title="Redis Cluster 101"></a>Redis Cluster 101</h2><p>Redis Cluster 提供了一种Redis安装方式，能够让数据自动的分片到多个Redis节点。</p>
<p>Redis Cluster 也在某种程度上通过分区来提供可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令。<br>在发生较大故障的时候集群会停止操作（例如大部分的主节点不可用的情况下）。<br>所以你会得到一个什么样的Redis Cluster?</p>
<ul>
<li>自动分割数据到不同的节点上的能力。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令的能力。</li>
</ul>
<h2 id="Redis-Cluster-TCP-ports"><a href="#Redis-Cluster-TCP-ports" class="headerlink" title="Redis Cluster TCP ports"></a>Redis Cluster TCP ports</h2><p>每个Redis Cluster节点必须有两个TCP链接被打开。正常情况下的Redis TCP端口使用的是6379来服务客户端，在这个数据端口的基础上加10000就可以获得集群使用的TCP端口，比如16379。第二个大的端口用于Cluster总线，节点和节点之间的通信采用二进制协议。这个Cluster总线用于对节点进行故障检测，配置更新，故障操作授权等等。Clients不要尝试和Cluster总线端口进行通信，应该使用Redis命令端口，在你的防火墙里面要打开这2个端口，否则其他Redis Cluster节点将不能够进行连接。</p>
<p>这个命令端口和cluster总线的端口的偏移量是固定的10000.<br>如果要让Redis集群环境很好的工作，每个节点都需要注意下面2点：</p>
<ol>
<li>用于正常通讯的端口（通常是6379）和集群环境的所有节点都能够正确的到达（使用这个端口进行键的迁移）。</li>
<li>这个集群总线的端口（客户端端口+10000）也必须和其他所有的集群节点互通。</li>
</ol>
<p>如果你没有打开这2个TCP端口，那你的集群环境将不能够工作。<br>集群总线使用的是二进制协议，作为节点到节点的数据交换，更适合用较小的带宽和处理时间来交换节点之间的信息。</p>
<h2 id="Redis-Cluster-and-Docker"><a href="#Redis-Cluster-and-Docker" class="headerlink" title="Redis Cluster and Docker"></a>Redis Cluster and Docker</h2><p>目前Redis Cluster 不支持NATted环境和常规环境中ip地址和端口的映射。</p>
<p>Docker使用了一种端口映射技术：程序会在Docker容器内部运行，可能会暴露一个不同的端口来给程序使用。在同一台服务器，同一时间内可以运行相同端口的多个容器，这是很有用的。<br>如果要在Doocker里面兼容Redis Cluster你需要采用host networking模式。请检查–net=host选项，更多的信息请阅读<a href="https://docs.docker.com/engine/userguide/networking/dockernetworks/" target="_blank" rel="noopener">Docker文档</a>。</p>
<h2 id="Redis-Cluster-data-sharding"><a href="#Redis-Cluster-data-sharding" class="headerlink" title="Redis Cluster data sharding"></a>Redis Cluster data sharding</h2><p>Redis Cluster 没有使用一致性哈希,而是使用的另一种分片方式 <strong>hash slot</strong>。</p>
<p>Redis集群里有16384个哈希槽，并且会计算出给定key的哈希槽是什么，我们是通过CRC16对16384取模来决定。<br>在集群里的每个节点负责一部分哈希槽的子集，比如你有3个节点的集群，那么：</p>
<ul>
<li>节点A包含0到5500的哈希槽。</li>
<li>节点B包含5501到11000的哈希槽。</li>
<li>节点C包含11001到16383的哈希槽。</li>
</ul>
<p>这样允许你很容易的在集群里添加并且删除节点。如果我想新增一个新的节点D，我只需要从节点A,B,C中移动某些哈希槽到D节点。同样如果我想从集群里面删除节点A，我只需把服务于A的哈希槽移动到B和C节点上。当节点A为空的时候我就可以把它从集群环境中完全的删除。</p>
<p>移动哈希槽从一个节点到另一个节点不需要停止操作，添加和删除节点，改变节点持有哈希槽的百分比，也不需要停机。</p>
<p>Redis集群支持多个key操作作为一个命令被执行（整个交易，或者Lua脚本的执行）在同一个哈希槽里。通过使用散列就可以强制多个key在同一个哈希槽里面。</p>
<p>散列标记在Redis集群规范里面提到，大致意思就是如果key里面有{}子串，就只会对这个花括号内的字符串进行哈希计算，比如一个{foo}key 和另一个{foo}key就保证在同一个哈希槽，这样就可以在同一个命令里面使用多个key作为参数使用。</p>
<h2 id="Redis-Cluster-master-slave-model"><a href="#Redis-Cluster-master-slave-model" class="headerlink" title="Redis Cluster master-slave model"></a>Redis Cluster master-slave model</h2><p>为了保证在部分主节点出现故障或者大部分节点无法通信的情况下仍然可用。Redis集群使用了主从模式，每个哈希槽从1（master自己）到N个副本（N-1个从节点）。</p>
<p>在我们的例子里集群拥有A,B,C三个节点，如果节点B失败了这个集群就不能够继续工作，在这个哈希槽的5501-11000范围内我们无法提供服务了。</p>
<p>所以我们在集群创建以后（或者过一段时间）我们要为每个主节点添加一个从节点，最终的集群组合是这样的：A,B,C是主节点，A1，B1，C1是他们的从节点，如果节点B失败了这个系统还是可以继续提供服务。</p>
<p>节点B1复制节点B，节点B失败后，集群将会推选节点B1作为新的主节点并且继续提供服务。</p>
<p>不过当节点B和B1都失败后，集群就不能够提供服务了。</p>
<h2 id="Redis-Cluster-consistency-guarantees"><a href="#Redis-Cluster-consistency-guarantees" class="headerlink" title="Redis Cluster consistency guarantees"></a>Redis Cluster consistency guarantees</h2><p>Redis集群不能够保证强一致性。这意味着在实际环境中集群在特定的条件下可能会丢失写操作。</p>
<p>为什么集群会丢失写主要原因是因为集群使用的是异步复制。写的流程如下：</p>
<ul>
<li>你的客户端向主节点B进行写操作。</li>
<li>主节点B回复了你的客户端OK。</li>
<li>主节点B将写的内容传播给其他从节点B1，B2和B3。</li>
</ul>
<p>正如你所看到的节点B并没有等待B1，B2，B3的确认就回复了客户端，因为这里考虑了性能问题，所以你的客户端在往节点B写入后，节点B会确认写操作，但是在它往其他从节点发送内容的时候崩掉了，这些从节点并没有接收到写的内容，此时有一个从节点被提升成了主节点，这个写的内容会被永久丢失。</p>
<p>这非常类似的和大多数数据库配置为每秒刷新数据到磁盘一样，你可以在响应客户端之前强制将数据刷新到磁盘，但是这会影响性能。这也是Redis集群中基于同步复制的一种方案。</p>
<p>基本上是在性能和一致性之前进行权衡。</p>
<p>Redis Cluster在某些必要的情况下也能够支持同步写，通过实施<a href="https://redis.io/commands/wait" target="_blank" rel="noopener">WAIT</a>命令，可以降低丢失写操作的可能性，要注意即使使用了同步复制<br>Redis集群也不能够保证强一致性：在更复杂的情况下，一个不接受写操作的从节点被提升为主节点的可能性总是存在。</p>
<p>这里还有另一种情况能够导致Redis集群丢失写操作，这发生在一个网络分区中，其中的一个客户端和一些少数的实例（至少包含一个主节点）被隔离在一起。<br>以我们的6个节点组成的集群环境为例子，A,B,C,A1，B1，C1，三个主节点和三个从节点。还有一个客户端，我们称为Z1。<br>发生网络分区,那么集群可能会分为两方，一方包含节点 A 、C 、A1 、B1 和 C1 ，另一方则包含节点 B 和客户端 Z1。<br>Z1仍然能够往主节点B中进行写操作, 如果网络分区发生时间较短,那么集群将会继续正常的运作,如果分区的时间足够让大部分的一方将B1选举为新的master节点，那么Z1写入B中得数据将会丢失掉。<br>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项。<br>节点超时后，主节点被认为失败了，并且能够被它的副本代替。主节点不能够感应其他的主节点，它将进入错误的状态并且停止写的接收。</p>
<h2 id="Redis-Cluster-configuration-parameters"><a href="#Redis-Cluster-configuration-parameters" class="headerlink" title="Redis Cluster configuration parameters"></a>Redis Cluster configuration parameters</h2><p>我们创建一个集群部署的例子。在这之前，让我们从redis.conf文件里了解一下Redis集群的配置参数。有些参数是很容易理解的，有些参数会随着你的继续阅读而越来越清晰。</p>
<ul>
<li><strong>cluster-enabled &lt;yes/no&gt;</strong> :  在指定的Redis实例中如果设置的是yes就会激活Redis集群。否则实例会作为一个独立实例来运行。</li>
<li><strong>cluster-config-file <filename></filename></strong>:注意虽然有这个名字的选项，但不是给用户编辑的配置文件，这个文件会随着集群环境的变化而自动改变，以便在启动时重新读取它。这个文件列出了其他节点的信息，他们的状态，变量等等。这个文件会因为某些消息的接收而重新将结果写到磁盘。</li>
<li><strong>cluster-node-timeout <milliseconds></milliseconds></strong>:这个是Redis集群节点不认为是失败的最大时间,如果在指定的时间内不能够到达其他节点，它将被其他从节点代替。这个参数的控制在集群里很重要。尤其是，每个节点不能够在指定的时间内到达大多数主节点，将停止接收查询操作。</li>
<li><strong>cluster-slave-validity-factor <factor></factor></strong>:如果设置为0，则从节点总是会尝试去对一个主节点进行故障转移，不管从节点和主节点断开的时间长度。如果值为正数，就会计算节点超时时间乘以这个因数得到最大的断开时间，如果这个节点是从节点，并且和主节点断开的连接时间超过了这个最大断开连接时间，就不会去尝试故障转移。举个例子：假设节点超时设置的是5秒，并且validity-factor设置的是10，一个从节点和主节点断开的时间超过了50秒就不会进行故障转移。注意任何一个非0的值都可能导致在主节点失败后没有从节点去进行故障转移而使得Redis集群不可用。这种情况下只有在原始的集群节点重新加入后才可以继续使用集群环境。</li>
<li><strong>cluster-migration-barrier <count></count></strong>:主节点保持连接从节点的最小值。查看关于副本迁移的内容  获取更多的信息。</li>
<li><strong>cluster-require-full-coverage &lt;yes/no&gt;</strong>: 默认情况下设置为yes，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。如果设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</li>
</ul>
<h2 id="Creating-and-using-a-Redis-Cluster"><a href="#Creating-and-using-a-Redis-Cluster" class="headerlink" title="Creating and using a Redis Cluster"></a>Creating and using a Redis Cluster</h2><p>注意：通过手动部署一个Redis集群环境也是很重要的一个学习环节。当然如果你想快速的获得一个可以运行的集群环境，可以跳过这一章节，直接通过使用create-cluster脚本来创建一个Redis集群环境。<br>创建一个集群环境，首先要有几个空实例运行在集群模式下。意味着集群的创建不使用正常的Redis实例，需要在激活了集群特性的基础上被创建。<br>以下是集群配置文件需要的最小配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p>
<p>我们看到通过cluster-enabled指令就可以激活集群模式。每个实例还包含了一个路径来存储这个配置文件，默认名字为nodes.conf。它会在Redis集群实例启动和每一次更新的时候需要。</p>
<p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。<br>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例。像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cluster-test</span><br><span class="line"><span class="built_in">cd</span> cluster-test</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure></p>
<p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码。<br>从 Redis Github 页面 的 unstable 分支中取出最新的 Redis 源码， 编译出可执行文件 redis-server ， 并将文件复制到 cluster-test 文件夹， 然后使用类似以下命令， 在每个标签页中打开一个实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 7000</span><br><span class="line">../redis-server ./redis.conf</span><br></pre></td></tr></table></figure></p>
<p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I<span class="string">'m 97a3a64667477371c4479320d683e4c8db5858b1</span></span><br></pre></td></tr></table></figure></p>
<p>这个ID将会永久的被这个实例使用以便这个实例在集群的上下文中具有唯一的名称。每个节点都会通过这个IDs来记住，而不是通过IP或者端口。IP地址和端口也许会改变，但这个唯一的节点身份不会改变，我们称为<strong>Node ID</strong>。</p>
<h2 id="Creating-the-cluster"><a href="#Creating-the-cluster" class="headerlink" title="Creating the cluster"></a>Creating the cluster</h2><p>现在我们已经有一些实例在运行，我们需要对这些节点写入一些有用的配置来创建我们的集群。<br>通过使用 Redis 集群命令行工具 redis-trib可以很容易帮助我们完成，这是一个Ruby写的可执行程序，能够发送特殊的命令来创建新的集群环境，检查或者重新分片一个已经存在的集群，等等。<br>这个redis-trib工具可以在src目录下面找到。你需要安装redis gem来运行redis-trib。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis</span><br></pre></td></tr></table></figure></p>
<p>简单的创建集群：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure></p>
<p>这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>其他的参数则是我想创建新集群环境的实例地址列表。<br>我们的要求是创建一个集群环境有3个主节点和3个从节点。<br>Redis-trib 会提供一份配置给你参考。如果你接收这份配置输入yes。 redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OK] All 16384 slots covered</span><br></pre></td></tr></table></figure></p>
<p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p>
<h2 id="Creating-a-Redis-Cluster-using-the-create-cluster-script"><a href="#Creating-a-Redis-Cluster-using-the-create-cluster-script" class="headerlink" title="Creating a Redis Cluster using the create-cluster script"></a>Creating a Redis Cluster using the create-cluster script</h2><p>如果你不想手动的去创建一个Redis集群环境，这里有一个非常简单的系统（但是你就不能够了解到更多的细节）。<br>在Redis分发目录里检查utils/create-cluster目录，这里有一个脚本文件create-cluster，这是一个简单的bash脚本。启动6个节点的集群环境，三主三从只需要执行以下流程的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. create-cluster start</span><br><span class="line">2. create-cluster create</span><br></pre></td></tr></table></figure></p>
<p> 在第二步回答yes后redis-trib就会根据你想要的集群布局来生效。<br>You can now interact with the cluster, the first node will start at port 30001 by default. When you are done, stop the cluster with:你现在可以和集群环境交互了，第一个生效的节点运行的端口是30001。完成后，停止这个集群环境:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. create-cluster stop.</span><br></pre></td></tr></table></figure></p>
<p>请阅读目录里面的README文件获取更多关于这样运行这个脚本。</p>
<h2 id="Playing-with-the-cluster"><a href="#Playing-with-the-cluster" class="headerlink" title="Playing with the cluster"></a>Playing with the cluster</h2><p>Redis 集群现阶段的一个问题是客户端实现的库很少。<br>我知道的有以下一些实现：</p>
<ul>
<li><a href="http://github.com/antirez/redis-rb-cluster" target="_blank" rel="noopener">redis-rb-cluster</a> is a Ruby implementation written by me (@antirez) as a reference for other languages. It is a simple wrapper around the original redis-rb, implementing the minimal semantics to talk with the cluster efficiently.</li>
<li><a href="https://github.com/Grokzen/redis-py-cluster" target="_blank" rel="noopener">redis-py-cluster</a> A port of redis-rb-cluster to Python. Supports majority of redis-py functionality. Is in active development.</li>
<li>The popular <a href="https://github.com/nrk/predis" target="_blank" rel="noopener">Predis</a> has support for Redis Cluster, the support was recently updated and is in active development.</li>
<li>The most used Java client, Jedis recently added support for Redis Cluster, see the <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis</a> Cluster section in the project README.</li>
<li><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener">StackExchange.Redis</a> offers support for C# (and should work fine with most .NET languages; VB, F#, etc)</li>
<li><a href="https://github.com/thunks/thunk-redis" target="_blank" rel="noopener">thunk-redis</a> offers support for Node.js and io.js, it is a thunk/promise-based redis client with pipelining and cluster.</li>
<li><a href="https://github.com/chasex/redis-go-cluster" target="_blank" rel="noopener">redis-go-cluster</a> is an implementation of Redis Cluster for the Go language using the Redigo library client as the base client. Implements MGET/MSET via result aggregation.</li>
<li>The redis-cli utility in the unstable branch of the Redis repository at GitHub implements a very basic cluster support when started with the -c switch.</li>
</ul>
<p>一个最简单的测试Redis集群环境的方法是尝试使用客户端或者redis-cli命令行工具。下面是命令行测试的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -c -p 7000</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7002&gt; <span class="built_in">set</span> hello world</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7000&gt; get foo</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line">redis 127.0.0.1:7000&gt; get hello</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line"><span class="string">"world"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：如果你时通过脚本创建的集群环境，你的节点可能监听的端口不同，默认是从30001开始。</p>
<p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p>
<h2 id="Writing-an-example-app-with-redis-rb-cluster"><a href="#Writing-an-example-app-with-redis-rb-cluster" class="headerlink" title="Writing an example app with redis-rb-cluster"></a>Writing an example app with redis-rb-cluster</h2><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。<br>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。<br>本节将通过两个示例应用来展示 <a href="http://github.com/antirez/redis-rb-cluster" target="_blank" rel="noopener">redis-rb-cluster</a> 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 <a href="https://github.com/antirez/redis-rb-cluster/blob/master/example.rb" target="_blank" rel="noopener">example.rb</a> 的文件， 包含在redis-rb-cluster 项目里面:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1  require <span class="string">'./cluster'</span></span><br><span class="line"> 2</span><br><span class="line"> 3  <span class="keyword">if</span> ARGV.length != 2</span><br><span class="line"> 4      startup_nodes = [</span><br><span class="line"> 5          &#123;:host =&gt; <span class="string">"127.0.0.1"</span>, :port =&gt; 7000&#125;,</span><br><span class="line"> 6          &#123;:host =&gt; <span class="string">"127.0.0.1"</span>, :port =&gt; 7001&#125;</span><br><span class="line"> 7      ]</span><br><span class="line"> 8  <span class="keyword">else</span></span><br><span class="line"> 9      startup_nodes = [</span><br><span class="line">10          &#123;:host =&gt; ARGV[0], :port =&gt; ARGV[1].to_i&#125;</span><br><span class="line">11      ]</span><br><span class="line">12  end</span><br><span class="line">13</span><br><span class="line">14  rc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)</span><br><span class="line">15</span><br><span class="line">16  last = <span class="literal">false</span></span><br><span class="line">17</span><br><span class="line">18  <span class="keyword">while</span> not last</span><br><span class="line">19      begin</span><br><span class="line">20          last = rc.get(<span class="string">"__last__"</span>)</span><br><span class="line">21          last = 0 <span class="keyword">if</span> !last</span><br><span class="line">22      rescue =&gt; e</span><br><span class="line">23          puts <span class="string">"error #&#123;e.to_s&#125;"</span></span><br><span class="line">24          sleep 1</span><br><span class="line">25      end</span><br><span class="line">26  end</span><br><span class="line">27</span><br><span class="line">28  ((last.to_i+1)..1000000000).each&#123;|x|</span><br><span class="line">29      begin</span><br><span class="line">30          rc.set(<span class="string">"foo#&#123;x&#125;"</span>,x)</span><br><span class="line">31          puts rc.get(<span class="string">"foo#&#123;x&#125;"</span>)</span><br><span class="line">32          rc.set(<span class="string">"__last__"</span>,x)</span><br><span class="line">33      rescue =&gt; e</span><br><span class="line">34          puts <span class="string">"error #&#123;e.to_s&#125;"</span></span><br><span class="line">35      end</span><br><span class="line">36      sleep 0.1</span><br><span class="line">37  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个应用程序所做的工作非常简单, 它不断地以 foo<number> 为键， number 为值， 使用 SET 命令向数据库设置键值对,所以程序运行的结果流程大致如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET foo0 0</span><br><span class="line">SET foo1 1</span><br><span class="line">SET foo2 2</span><br><span class="line">And so forth...</span><br></pre></td></tr></table></figure></number></p>
<p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。<br>程序的第14行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得的最大连接数 ，第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。<br>启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的。 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的的集群客户端都应该这样做。<br>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。<br>在18至26行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。<br>28至37行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。执行 example.rb 程序将产生以下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ruby ./example.rb</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">^C (I stopped the program here)</span><br></pre></td></tr></table></figure></p>
<p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p>
<h2 id="Resharding-the-cluster"><a href="#Resharding-the-cluster" class="headerlink" title="Resharding the cluster"></a>Resharding the cluster</h2><p>现在， 让我们来试试对集群进行重新分片操作。在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行 重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行 执行以下命令可以开始一次重新分片操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb reshard 127.0.0.1:7000</span><br></pre></td></tr></table></figure></p>
<p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。<br>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 你不能说从一个节点移动5%的哈希槽到另一个节点。所以从一开始，首先就要确定重新分片的数量是多少个:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)?</span><br></pre></td></tr></table></figure></p>
<p>我们尝试重新对1000个哈希槽分片，如果我们的例子程序（example.rb）还在运行的话，那么应该有一定数量的键了。 然后redis-trib需要知道重新分片的目标是什么，也就是将要接收这些哈希槽的节点。我将使用第一个主节点，127.0.0.1:7000，但是我需要制定这个实例的节点ID。我们可以通过以下的命令获取到节点id:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep myself</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460</span><br></pre></td></tr></table></figure></p>
<p>好啦，我的目标节点ID是 97a3a64667477371c4479320d683e4c8db5858b1。<br>现在你将会被问到从哪些节点去获取这些键。我只需要输入all就可以从所有的主节点各获取一部分哈希槽。<br>最后确认后你将会看到每个redis-trib移动的槽的信息，每个key的移动的信息也会打印出来。<br>在重新分片的过程中，你的例子程序是不会受到影响的,你可以停止或者重新启动多次。<br>在重新分片结束后，你可以通过如下命令检查集群状态:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb check 127.0.0.1:7000</span><br></pre></td></tr></table></figure></p>
<p>所有的插槽都将会被覆盖，但是这个主节点127.0.0.1:7000将会拥有更多的哈希槽，大约6461个。</p>
<h2 id="Scripting-a-resharding-operation"><a href="#Scripting-a-resharding-operation" class="headerlink" title="Scripting a resharding operation"></a>Scripting a resharding operation</h2><p>重新分片过程还可以自动执行而不需要互动，手动指定一些参数即可，命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb reshard --from &lt;node-id&gt; --to &lt;node-id&gt; --slots &lt;number of slots&gt; --yes &lt;host&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样的方式就可以经常自动的进行重新分片，目前redis-trib还不能够很好的自动重新负载集群，此功能会在将来添加。</p>
<h2 id="A-more-interesting-example-application"><a href="#A-more-interesting-example-application" class="headerlink" title="A more interesting example application"></a>A more interesting example application</h2><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。</p>
<p>比如说， 集群可能会错误地将 example.rb 发送的所有 SET 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值，我们并不会注意到集群实际上写入的值是错误的。<br>redis-rb-cluster项目里面有一个更有趣的程序是consistency-test.rb。 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR 命令来增加这些计数器的值。<br>程序不仅仅是写操作，它做了两件事：</p>
<ul>
<li>使用INCR更新计数器的值，程序进行写操作。</li>
<li>它在写之前会随机的去读取一个计数器，并且检查这个值是否是预期的值。</li>
</ul>
<p>换句话说， 这个程序是一个简单的一致性检查器（consistency checker），并且能够告诉你集群里面哪些写操作丢失，又或者多执行了某些客户端没有确认到的 INCR 命令。在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。<br>运行 consistency-test 程序将产生类似以下的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ruby consistency-test.rb</span><br><span class="line">925 R (0 err) | 925 W (0 err) |</span><br><span class="line">5030 R (0 err) | 5030 W (0 err) |</span><br><span class="line">9261 R (0 err) | 9261 W (0 err) |</span><br><span class="line">13517 R (0 err) | 13517 W (0 err) |</span><br><span class="line">17780 R (0 err) | 17780 W (0 err) |</span><br><span class="line">22025 R (0 err) | 22025 W (0 err) |</span><br><span class="line">25818 R (0 err) | 25818 W (0 err) |</span><br></pre></td></tr></table></figure></p>
<p>结果展示了执行的读和 写,和错误(由于系统不可用而没有接受的查询发生的错误）的数量。<br>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 7000 <span class="built_in">set</span> key_217 0</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">(<span class="keyword">in</span> the other tab I see...)</span><br><span class="line"></span><br><span class="line">94774 R (0 err) | 94774 W (0 err) |</span><br><span class="line">98821 R (0 err) | 98821 W (0 err) |</span><br><span class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</span><br><span class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</span><br></pre></td></tr></table></figure></p>
<p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR 命令。<br>这个程序作为测试程序很有意思，所以我们用这个程序来测试故障恢复.</p>
<h2 id="Testing-the-failover"><a href="#Testing-the-failover" class="headerlink" title="Testing the failover"></a>Testing the failover</h2><p>注意：在这个测试过程中，你要一直运行consistency test程序。<br>要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。首先用以下命令列出集群中的所有主节点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep master</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br></pre></td></tr></table></figure></p>
<p>通过命令输出得知端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为7002 的主节点发送 DEBUG SEGFAULT 命令， 让这个主节点崩溃：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7002 debug segfault</span><br><span class="line">Error: Server closed the connection</span><br></pre></td></tr></table></figure></p>
<p>现在我们查看consistency test输出的报表信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">18849 R (0 err) | 18849 W (0 err) |</span><br><span class="line">23151 R (0 err) | 23151 W (0 err) |</span><br><span class="line">27302 R (0 err) | 27302 W (0 err) |</span><br><span class="line"></span><br><span class="line">... many error warnings here ...</span><br><span class="line"></span><br><span class="line">29659 R (578 err) | 29660 W (577 err) |</span><br><span class="line">33749 R (578 err) | 33750 W (577 err) |</span><br><span class="line">37918 R (578 err) | 37919 W (577 err) |</span><br><span class="line">42077 R (578 err) | 42078 W (577 err) |</span><br></pre></td></tr></table></figure></p>
<p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。现在， 让我们使用 cluster nodes 命令,查看集群在执行故障转移操作之后， 主从节点的布局情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</span><br></pre></td></tr></table></figure></p>
<p>现在masters运行在 7000, 7001 和 7005端口上. 原来的master 7002现在变成了一个7005的一个从节点.<br>CLUSTER NODES 命令的输出看起来有点复杂,其实他非常的简单，含义如下:</p>
<ul>
<li>节点ID</li>
<li>IP:端口</li>
<li>标志: master, slave, myself, fail, …</li>
<li>如果是个从节点, 这里是它的主节点的NODE ID</li>
<li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。.</li>
<li>节点最近一次返回 PONG 回复的时间。</li>
<li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li>
<li>节点连接状态。</li>
<li>哈希槽的服务。</li>
</ul>
<h2 id="Manual-failover"><a href="#Manual-failover" class="headerlink" title="Manual failover"></a>Manual failover</h2><p>有的时候在主节点没有任何问题的情况下强制手动故障转移也是很有必要的，比如想要升级主节点的Redis进程，我们可以通过故障转移将其转为slave再进行升级操作来避免对集群的可用性造成很大的影响。<br>Redis集群使用 <a href="https://redis.io/commands/cluster-failover" target="_blank" rel="noopener">CLUSTER FAILOVER</a>命令来进行故障转移，不过要在被转移的主节点的从节点上执行该命令。<br>手动故障转移比主节点失败自动故障转移更加安全，因为手动故障转移时客户端的切换是在确保新的主节点完全复制了失败的旧的主节点数据的前提下下发生的，所以避免了数据的丢失。</p>
<p>执行手动故障转移时查看从节点日志记录如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Manual failover user request accepted.</span></span><br><span class="line"><span class="comment"># Received replication offset for paused master manual failover: 347540</span></span><br><span class="line"><span class="comment"># All master replication stream processed, manual failover can start.</span></span><br><span class="line"><span class="comment"># Start of election delayed for 0 milliseconds (rank #0, offset 347540).</span></span><br><span class="line"><span class="comment"># Starting a failover election for epoch 7545.</span></span><br><span class="line"><span class="comment"># Failover election won: I'm the new master.</span></span><br></pre></td></tr></table></figure></p>
<p>基本过程如下：客户端不再链接我们淘汰的主节点，同时主节点向从节点发送复制偏移量,从节点得到复制偏移量后故障转移开始,接着通知主节点进行配置切换,当客户端在旧的master上解锁后重新连接到新的主节点上。</p>
<h2 id="Adding-a-new-node"><a href="#Adding-a-new-node" class="headerlink" title="Adding a new node"></a>Adding a new node</h2><p>添加新的节点的基本过程就是添加一个空的节点然后移动一些数据给它,一种情况是添加一个新的主节点,或者告诉这个节点设置为一个已知节点的副本，这种情况下它是一个从节点。<br>针对这两种情况，本节都会介绍，先从添加主节点开始。<br>两种情况执行的第一步都是添加一个空节点。<br>启动一个端口为7006的新节点（在我们已存在的6个节点里已经使用了7000到7005的端口），使用和其他节点相同的配置，除了端口不一样，按照以下流程执行：</p>
<ul>
<li>在终端打开一个新的标签页。</li>
<li>进入cluster-test 目录。</li>
<li>创建一个名为7006的目录。</li>
<li>和其他节点一样，创建redis.conf文件,需要将端口号改成7006.</li>
<li>最后启动节点 ../redis-server ./redis.conf</li>
</ul>
<p>此时服务应该能够正常运行。<br>现在我们使用redis-trib手动将这个节点添加到已存在的集群环境。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure></p>
<p>可以看到.使用<strong>add-node</strong>命令来添加节点，第一个参数是新节点的地址，第二个参数是任意一个已经存在的节点的IP和端口。<br>在操作过程中redis-trib其实帮助我们做了很少的事情，它只是给这个节点发送了一个<a href="https://redis.io/commands/cluster-meet" target="_blank" rel="noopener">CLUSTER MEET</a>消息,这件事情你也可以手动执行。<br>redis-trib在操作之前会检查集群的状态，所以用redis-trib来执行操作是比较好的范式。<br>我们可以看到新的节点已经添加到集群中:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster nodes</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</span><br></pre></td></tr></table></figure></p>
<p>新节点现在已经连接上了集群环境， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别：</p>
<ul>
<li>新节点不包含数据，也没有指定哈希槽.</li>
<li>因为这个主节点没有指定哈希槽，所以当从节点想提升为主节点的时候它不会参加选举。<br>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</li>
</ul>
<h2 id="Adding-a-new-node-as-a-replica"><a href="#Adding-a-new-node-as-a-replica" class="headerlink" title="Adding a new node as a replica"></a>Adding a new node as a replica</h2><p>我们有两种方式添加新的副本。可以像添加主节点一样再次使用redis-trib 命令，但是要加上–slave选项，像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure></p>
<p>此处的命令和添加一个主节点命令类似，此处并没有指定添加的这个从节点的主节点，这种情况下系统会在其他的复制集中的主节点中随机选取一个作为这个从节点的主节点。<br>当然你也可以使用以下命令来指定这个新副本的主节点是哪个:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure></p>
<p>这样我们就为新副本指定了一个主节点。<br>还有另一种方式就是通过使用<a href="https://redis.io/commands/cluster-replicate" target="_blank" rel="noopener">CLUSTER REPLICATE</a>命令转换一个空的主节点为另一个主节点的从节点。<br>举个例子：在我们的节点里面有一个节点127.0.0.1:7005 目前是节点IDNode ID为 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e的副本，只需要连接到新的节点（空主节点）发送以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure></p>
<p>就可以了。 我们新的从节点有了一些哈希槽，其他的节点也知道（过几秒后会更新他们自己的配置），可以使用如下命令确认::<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</span><br></pre></td></tr></table></figure></p>
<p>节点 3c3a0c… 有两个从节点， 7002 (已经存在的) 和 7006 (新添加的)。</p>
<h2 id="Removing-a-node"><a href="#Removing-a-node" class="headerlink" title="Removing a node"></a>Removing a node</h2><p>只需要通过redis-trib的del-node命令就可以移除一个从节点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib del-node 127.0.0.1:7000 `&lt;node-id&gt;`</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是集群中随机的一个节点，第二个参数是你想删除的节点ID。<br>使用同样的方法移除主节点,不过在移除主节点前，<strong>需要确保这个主节点是空的</strong>。如果不是空的,需要将这个节点的数据重新分片到其他主节点上。<br>移除的另一种方法是手动执行故障转移，等从节点作为新的主节点后在将它删除，不过这种情况下不会减少集群节点的数量，这种情况下，需要重新分片。</p>
<h2 id="Replicas-migration"><a href="#Replicas-migration" class="headerlink" title="Replicas migration"></a>Replicas migration</h2><p>在集群环境里可以在任何时间执行以下命令来重新配置从节点对应的主节点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure></p>
<p>在特定的场景下，不需要系统管理员的协助下，自动将一个从节点从当前的主节点切换到另一个主节 的自动重新配置的过程叫做复制迁移（从节点迁移），从节点的迁移能够提高整个Redis集群的可用性。<br>注意：你可以阅读（<a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis集群规范</a>）了解细节。在这里我们只提供一部分信息告诉你怎么做。<br>The reason why you may want to let your cluster replicas to move from one master to another under certain condition, is that usually the Redis Cluster is as resistant to failures as the number of replicas attached to a given master.<br>For example a cluster where every master has a single replica can’t continue operations if the master and its replica fail at the same time, simply because there is no other instance to have a copy of the hash slots the master was serving. However while netsplits are likely to isolate a number of nodes at the same time, many other kind of failures, like hardware or software failures local to a single node, are a very notable class of failures that are unlikely to happen at the same time, so it is possible that in your cluster where every master has a slave, the slave is killed at 4am, and the master is killed at 6am. This still will result in a cluster that can no longer operate.<br>To improve reliability of the system we have the option to add additional replicas to every master, but this is expensive. Replica migration allows to add more slaves to just a few masters. So you have 10 masters with 1 slave each, for a total of 20 instances. However you add, for example, 3 instances more as slaves of some of your masters, so certain masters will have more than a single slave.<br>With replicas migration what happens is that if a master is left without slaves, a replica from a master that has multiple slaves will migrate to the orphaned master. So after your slave goes down at 4am as in the example we made above, another slave will take its place, and when the master will fail as well at 5am, there is still a slave that can be elected so that the cluster can continue to operate.<br>So what you should know about replicas migration in short?</p>
<ul>
<li>The cluster will try to migrate a replica from the master that has the greatest number of replicas in a given moment.</li>
<li>To benefit from replica migration you have just to add a few more replicas to a single master in your cluster, it does not matter what master.</li>
<li>There is a configuration parameter that controls the replica migration feature that is called cluster-migration-barrier: you can read more about it in the example redis.conf file provided with Redis Cluster.</li>
</ul>
<h2 id="Upgrading-nodes-in-a-Redis-Cluster"><a href="#Upgrading-nodes-in-a-Redis-Cluster" class="headerlink" title="Upgrading nodes in a Redis Cluster"></a>Upgrading nodes in a Redis Cluster</h2><p>Upgrading slave nodes is easy since you just need to stop the node and restart it with an updated version of Redis. If there are clients scaling reads using slave nodes, they should be able to reconnect to a different slave if a given one is not available.<br>Upgrading masters is a bit more complex, and the suggested procedure is:</p>
<ol>
<li>Use CLUSTER FAILOVER to trigger a manual failover of the master to one of its slaves (see the “Manual failover” section of this documentation).</li>
<li>Wait for the master to turn into a slave.</li>
<li>Finally upgrade the node as you do for slaves.</li>
<li>If you want the master to be the node you just upgraded, trigger a new manual failover in order to turn back the upgraded node into a master.</li>
</ol>
<p>Following this procedure you should upgrade one node after the other until all the nodes are upgraded.</p>
<h2 id="Migrating-to-Redis-Cluster"><a href="#Migrating-to-Redis-Cluster" class="headerlink" title="Migrating to Redis Cluster"></a>Migrating to Redis Cluster</h2><p>Users willing to migrate to Redis Cluster may have just a single master, or may already using a preexisting sharding setup, where keys are split among N nodes, using some in-house algorithm or a sharding algorithm implemented by their client library or Redis proxy.<br>In both cases it is possible to migrate to Redis Cluster easily, however what is the most important detail is if multiple-keys operations are used by the application, and how. There are three different cases:</p>
<ol>
<li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys, are not used. Keys are accessed independently (even if accessed via transactions or Lua scripts grouping multiple commands, about the same key, together).</li>
<li>Multiple keys operations, transactions, or Lua scripts involving multiple keys are used but only with keys having the same hash tag, which means that the keys used together all have a {…} sub-string that happens to be identical. For example the following multiple keys operation is defined in the context of the same hash tag: SUNION {user:1000}.foo {user:1000}.bar.</li>
<li>Multiple keys operations, transactions, or Lua scripts involving multiple keys are used with key names not having an explicit, or the same, hash tag.</li>
</ol>
<p>The third case is not handled by Redis Cluster: the application requires to be modified in order to don’t use multi keys operations or only use them in the context of the same hash tag.<br>Case 1 and 2 are covered, so we’ll focus on those two cases, that are handled in the same way, so no distinction will be made in the documentation.<br>Assuming you have your preexisting data set split into N masters, where N=1 if you have no preexisting sharding, the following steps are needed in order to migrate your data set to Redis Cluster:</p>
<ol>
<li>Stop your clients. No automatic live-migration to Redis Cluster is currently possible. You may be able to do it orchestrating a live migration in the context of your application / environment.</li>
<li>Generate an append only file for all of your N masters using the BGREWRITEAOF command, and waiting for the AOF file to be completely generated.</li>
<li>Save your AOF files from aof-1 to aof-N somewhere. At this point you can stop your old instances if you wish (this is useful since in non-virtualized deployments you often need to reuse the same computers).</li>
<li>Create a Redis Cluster composed of N masters and zero slaves. You’ll add slaves later. Make sure all your nodes are using the append only file for persistence.</li>
<li>Stop all the cluster nodes, substitute their append only file with your pre-existing append only files, aof-1 for the first node, aof-2 for the second node, up to aof-N.</li>
<li>Restart your Redis Cluster nodes with the new AOF files. They’ll complain that there are keys that should not be there according to their configuration.</li>
<li>Use redis-trib fix command in order to fix the cluster so that keys will be migrated according to the hash slots each node is authoritative or not.</li>
<li>Use redis-trib check at the end to make sure your cluster is ok.</li>
<li>Restart your clients modified to use a Redis Cluster aware client library.</li>
</ol>
<p>There is an alternative way to import data from external instances to a Redis Cluster, which is to use the redis-trib import command.<br>The command moves all the keys of a running instance (deleting the keys from the source instance) to the specified pre-existing Redis Cluster. However note that if you use a Redis 2.8 instance as source instance the operation may be slow since 2.8 does not implement migrate connection caching, so you may want to restart your source instance with a Redis 3.x version before to perform such operation.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/10/15/Redis-Replication-Keepalived/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/15/Redis-Replication-Keepalived/" itemprop="url">
                  Redis Replication+Keepalived
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-10-15 21:37:26" itemprop="dateCreated datePublished" datetime="2016-10-15T21:37:26+08:00">2016-10-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/10/15/Redis-Replication-Keepalived/" class="leancloud_visitors" data-flag-title="Redis Replication+Keepalived">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>以下是测试环境:</p>
<table>
<thead>
<tr>
<th>系统环境</th>
<th>IP地址</th>
<th style="text-align:center">节点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.92</td>
<td style="text-align:center">Master</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.93</td>
<td style="text-align:center">Slave(用于备份服务器)</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.94</td>
<td style="text-align:center">VIP</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.17</td>
<td style="text-align:center">Client</td>
</tr>
</tbody>
</table>
<p>Master和Slave都执行以下操作，参考文档进行安装：<br><a href="https://redis.io/topics/quickstart" target="_blank" rel="noopener">https://redis.io/topics/quickstart</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ yum install ntp -y</span><br><span class="line">$ ntpdate -u cn.pool.ntp.org</span><br><span class="line">$ yum install gcc -y</span><br><span class="line">$ wget http://download.redis.io/redis-stable.tar.gz</span><br><span class="line">$ tar xvzf redis-stable.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-stable</span><br><span class="line">$ make</span><br><span class="line">$ yum install tcl -y</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line">$ cp src/redis-server /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">$ cp src/redis-cli /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line">$ mkdir /etc/redis</span><br><span class="line">$ mkdir /var/redis</span><br><span class="line">$ cp utils/redis_init_script /etc/init.d/redis_6379</span><br><span class="line">$ cp redis.conf /etc/redis/6379.conf</span><br><span class="line">$ mkdir /var/redis/6379</span><br></pre></td></tr></table></figure></p>
<p>编辑配置文件，确保执行了以下的更改，测试环境可以不设置密码：<br>[root@localhost redis-stable]# vim /etc/redis/6379.conf</p>
<ol>
<li>Set daemonize to yes (by default it is set to no).</li>
<li>Set the pidfile to /var/run/redis_6379.pid (modify the port if needed).</li>
<li>Change the port accordingly. In our example it is not needed as the default port is already 6379.</li>
<li>Set your preferred loglevel.</li>
<li>Set the logfile to /var/log/redis_6379.log</li>
<li>Set the dir to /var/redis/6379 (very important step!)</li>
<li>Set the bind to 0.0.0.0</li>
<li>Set the requirepass (very important step!)</li>
</ol>
<p>启动redis服务试试:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># service redis_6379 start</span></span><br><span class="line">Starting Redis server...</span><br><span class="line">[root@localhost ~]<span class="comment"># redis-cli ping</span></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></p>
<p>启动以后检查日志文件，发现会有很多警告信息，执行以下操作解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 511 &gt; /proc/sys/net/core/somaxconn</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"echo 511 &gt; /proc/sys/net/core/somaxconn"</span> &gt;&gt; /etc/rc.local</span><br><span class="line">$ sysctl vm.overcommit_memory=1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"vm.overcommit_memory=1"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">$ <span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>
<h2 id="LVS安装"><a href="#LVS安装" class="headerlink" title="LVS安装"></a>LVS安装</h2><p>通过lvs源码安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install ipvsadm -y</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ipvsadm -v</span></span><br><span class="line">ipvsadm v1.26 2008/5/15 (compiled with popt and IPVS v1.2.1)</span><br><span class="line">------------------------------------------------------or------------------------------</span><br><span class="line">[root@localhost]<span class="comment"># wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz</span></span><br><span class="line">[root@localhost ipvsadm-1.26]<span class="comment"># tar zxf ipvsadm-1.26.tar.gz</span></span><br><span class="line">[root@localhost ipvsadm-1.26]<span class="comment"># make</span></span><br><span class="line">[root@localhost ipvsadm-1.26]<span class="comment"># make install</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>检查linux内核是否集成lvs模块,开启路由转发功能,以及ip_vs模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># modprobe -l | grep ipvs</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "echo 1 &gt; /proc/sys/net/ipv4/ip_forward" &gt;&gt; /etc/rc.local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># modprobe ip_vs</span></span><br><span class="line">[root@localhost ~]<span class="comment"># modprobe ip_vs_wrr</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "modprobe ip_vs" &gt;&gt; /etc/rc.local </span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "modprobe ip_vs_wrr" &gt;&gt; /etc/rc.local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># lsmod | grep ip_vs</span></span><br><span class="line">ip_vs_wrr               2179  1 </span><br><span class="line">ip_vs                 126705  3 ip_vs_wrr</span><br><span class="line">libcrc32c               1246  1 ip_vs</span><br><span class="line">ipv6                  336368  47 ip_vs,bridge,ip6t_REJECT,nf_conntrack_ipv6,nf_defrag_ipv6</span><br></pre></td></tr></table></figure></p>
<h2 id="keepalived安装"><a href="#keepalived安装" class="headerlink" title="keepalived安装"></a>keepalived安装</h2><p>以下是Master和Slave都要进行的操作：<br>从官网下载源码包 <a href="http://www.keepalived.org/download.html" target="_blank" rel="noopener">http://www.keepalived.org/download.html</a> ,安装相应的依赖库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]<span class="comment"># yum install -y gcc gcc-c++ makepcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel libnfnetlink-devel openssl-devel popt-static</span></span><br><span class="line">[root@localhost]<span class="comment"># yum update glib* -y</span></span><br><span class="line">[root@localhost opt]<span class="comment"># wget http://www.keepalived.org/software/keepalived-1.2.24.tar.gz</span></span><br><span class="line">[root@localhost opt]<span class="comment"># tar zxf keepalived-1.2.24.tar.gz</span></span><br><span class="line">[root@localhost opt]<span class="comment"># cd keepalived-1.2.24</span></span><br><span class="line">[root@localhost]<span class="comment"># ./configure --prefix=/usr/local/keepalived</span></span><br><span class="line">[root@localhost]<span class="comment"># make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></p>
<p>创建keepalived服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/sbin/keepalived /usr/sbin/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/keepalived /etc/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod +x /usr/local/keepalived/etc/rc.d/init.d/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># keepalived -v</span></span><br></pre></td></tr></table></figure></p>
<h3 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     jun.chen@cyberkey.cn</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from redis_master@cyberkey.cn</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id REDIS-HA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_redis &#123;</span><br><span class="line">	<span class="comment">#script "pidof redis-server"</span></span><br><span class="line">    script <span class="string">"/etc/keepalived/scripts/redis_check.sh"</span></span><br><span class="line">    interval 2</span><br><span class="line">    timeout 2</span><br><span class="line">    weight -100</span><br><span class="line">    fall 2</span><br><span class="line">    rise 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 58</span><br><span class="line">    priority 200</span><br><span class="line">    advert_int 1</span><br><span class="line">    nopreempt</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.94/24 dev eth0 scope global label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_redis</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#notify_master "/usr/local/bin/redis-cli SLAVEOF NO ONE"</span></span><br><span class="line">    <span class="comment">#notify_backup "/usr/local/bin/redis-cli SLAVEOF 192.168.1.93 6379"</span></span><br><span class="line">    notify_master <span class="string">"/etc/keepalived/scripts/redis_master.sh"</span></span><br><span class="line">    notify_backup <span class="string">"/etc/keepalived/scripts/redis_backup.sh"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slave配置"><a href="#slave配置" class="headerlink" title="slave配置"></a>slave配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     jun.chen@cyberkey.cn</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from redis_slave@cyberkey.cn</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id REDIS-HA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_redis &#123;</span><br><span class="line">	<span class="comment">#script "pidof redis-server"</span></span><br><span class="line">    script <span class="string">"/etc/keepalived/scripts/redis_check.sh"</span></span><br><span class="line">    interval 2</span><br><span class="line">    timeout 2</span><br><span class="line">    weight -100</span><br><span class="line">    fall 2</span><br><span class="line">    rise 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 58</span><br><span class="line">    priority 150</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.94/24 dev eth0 scope global label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_redis</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#notify_master "/usr/local/bin/redis-cli SLAVEOF NO ONE"</span></span><br><span class="line">    <span class="comment">#notify_backup "/usr/local/bin/redis-cli SLAVEOF 192.168.1.92 6379"</span></span><br><span class="line">    notify_master <span class="string">"/etc/keepalived/scripts/redis_master.sh"</span></span><br><span class="line">    notify_backup <span class="string">"/etc/keepalived/scripts/redis_backup.sh"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="master脚本"><a href="#master脚本" class="headerlink" title="master脚本"></a>master脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /etc/keepalived/scripts</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/scripts/redis_check.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-cli ping</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/scripts/redis_master.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-cli SLAVEOF NO ONE</span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/scripts/redis_backup.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-cli SLAVEOF 192.168.1.93 6379</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod +x /etc/keepalived/scripts/*</span></span><br></pre></td></tr></table></figure>
<h3 id="slave脚本"><a href="#slave脚本" class="headerlink" title="slave脚本"></a>slave脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /etc/keepalived/scripts</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/scripts/redis_check.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-cli ping</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">   <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/scripts/redis_master.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-cli SLAVEOF NO ONE</span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/scripts/redis_backup.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-cli SLAVEOF 192.168.1.92 6379</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod +x /etc/keepalived/scripts/*</span></span><br></pre></td></tr></table></figure>
<h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><p>打开redis端口和vrrp端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/sysconfig/iptables</span></span><br><span class="line">-A INPUT -p vrrp -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT</span><br><span class="line">[root@localhost ~]<span class="comment"># service iptables restart</span></span><br></pre></td></tr></table></figure></p>
<h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>启动master节点的redis和keepalived,启动slave节点的redis和keepalived.查看主从关系:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># redis-cli -h 192.168.1.94 INFO | grep slave0</span></span><br><span class="line">slave0:ip=192.168.1.93,port=6379,state=online,offset=785,lag=0</span><br></pre></td></tr></table></figure></p>
<p>停掉master节点的redis或者keepalived，在重启redis或者keepalived,查看主从关系:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># redis-cli -h 192.168.1.94 INFO | grep slave0</span></span><br><span class="line">slave0:ip=192.168.1.92,port=6379,state=online,offset=2339,lag=0</span><br></pre></td></tr></table></figure></p>
<p>还可以试试添加一个key值后同步的效果。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/10/14/Redis-Replication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/14/Redis-Replication/" itemprop="url">
                  Redis Replication
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-10-14 20:37:26" itemprop="dateCreated datePublished" datetime="2016-10-14T20:37:26+08:00">2016-10-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/10/14/Redis-Replication/" class="leancloud_visitors" data-flag-title="Redis Replication">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>基于redis的复制有一种简单的方式是通过配置master-slave就可以允许从节点去精确的复制主节点信息。从节点会自动的在任意时刻保持与主节点的连接，无论master节点做了什么，从节点都将精确的复制这些内容。<br>这种机制工作主要由三部分组成：</p>
<ol>
<li>当一个主节点和一个从节点实例连接后，这个主节点会发送一个流来保持与从节点的更新，以便主节点的数据集发生变化后能够通知从节点：客户端的写，keys的过期或者剔除，等等。</li>
<li>当主节点和从节点断开了，可能是网络问题或者是超时了，从节点会重试连接并且尝试一部分重新同步：意味着会尝试丢失过后的那部分内容。</li>
<li>当重新同步内容也失败了，从节点将重新同步完整的内容。这将涉及到更复杂的处理过程，主程序需要创建一个完整的数据快照，在发送给从节点，最后在继续发送命令流作为数据集的交换。</li>
</ol>
<p>Redis默认采用的是异步复制方式，具有高性能和高延迟，在绝大多数情况下复制都是很自然的。只是Redis从节点是定期的去异步接收这个主节点的数据。</p>
<p>客户端可以使用<a href="https://redis.io/commands/wait" target="_blank" rel="noopener">WAIT</a>命令来作为某些数据请求时的同步复制。但是WAIT只能确保其他实例对你指定的数据进行确认复制：</p>
<p>因为某些错误而进行故障转移期间或者配置了Redis持久化的情况下确认写操作也会丢失数据。 你可以查阅Sentinel或者Redis集群文档来获取更多关于高可用和故障转移的信息。该文档的其余部门描述了Redis的基本复制功能。<br>以下是关于Redis复制的重要流程说明：</p>
<ul>
<li>Redis使用的是异步复制，基于异步方式来确认slave-to-master的数据处理。</li>
<li>一个主节点可以有多个从节点。</li>
<li>从节点也可以接受其他从节点的连接。除了可以接受同一个master下面slaves的连接以外，还可以接受同一个结构图中的其他slaves的连接。从4.0版本开始，所有的从节点将从同一个主节点接收相同的复制流。</li>
<li>Redis复制在master端是非阻塞的。也就是说这个主节点在从节点同步的过程中会继续接受查询操作。</li>
<li>在从节点端的复制基本上也是非阻塞的。当从节点在执行初始化同步的时候，它能够使用旧版本的数据集提供查询处理，假设你在redis.conf配置里这样做了。 否则，你可以配置Redis当你的复制流被关闭后从节点返回一个错误给客户端。但是，在初始化同步执行以后，这个旧的数据集必须被删除并且新的数据必须被加载。在这个简短的过程中从节点将会阻止传进来的连接（如果数据集非常大的话可能需要很多秒）。4.0版本会提供一个不同的线程来删除旧的数据，但是加载新的数据集任然在主线程中处理，并且被阻止连接。</li>
<li>复制具有伸缩性，可以有多个从节点作为只读查询（比如慢的操作可以交给从节点），或者为了数据的安全。</li>
<li>可以使用复制来避免主节点将完整的数据集写入到磁盘：一种典型的技术就是配置主节点的redis.conf来避免所有数据持久化到磁盘，然后将连接的从节点配置为时不时的去保存，或者激活AOF。但是这种设置必须要小心，因为重新启动主节点后将会以空数据集运行：如果从节点尝试去同步它，这个从节点也将会成为空。</li>
</ul>
<h2 id="Safety-of-replication-when-master-has-persistence-turned-off"><a href="#Safety-of-replication-when-master-has-persistence-turned-off" class="headerlink" title="Safety of replication when master has persistence turned off"></a>Safety of replication when master has persistence turned off</h2><p>在设置Redis复制的时候，强烈建议在主节点和从节点上打开持久化功能。如果确实不想持久化的话，比如因为磁盘读写性能的原因，实例也要避免重启系统后自动重启服务。</p>
<p>为了更好的理解为什么主节点在持久化关闭后配置了自动重启是很危险的，按照以下流程来测试数据被擦除的故障模式：</p>
<ol>
<li>我们设置了一个节点A作为主节点，关闭了持久化，并且节点B和C复制节点A.</li>
<li>节点A崩溃了，系统在某个时候自动重启了，也重启了这个进程。<br>由于持久化被关闭了，这个节点会以空数据集重新启动。</li>
<li>节点B和C将复制节点A的内容，因为是空的，所以他们的副本数据也被摧毁了。<br>当使用Redis Sentinel作为高可用方案是，也在主节点上关闭了持久化，自动重启了进程，也是很危险的。比如主节点很快的重启Sentinel没有检测到这个故障，所以上面的失败模式也会发生。</li>
</ol>
<p>任何时刻的数据都很重要，如果主节点配置在复制的时候没有持久化，自动重启应该被禁止掉。</p>
<h2 id="How-Redis-replication-works"><a href="#How-Redis-replication-works" class="headerlink" title="How Redis replication works"></a>How Redis replication works</h2><p>每个Redis主节点都有一个复制ID：它是一个大的随机数来标记这个数据集。每个主节点还需要一个偏移量，来更新数据集的状态到哪儿了。<br>即使没有从节点连接这个复制的偏移量也会增加，所以都是成对出现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Replication ID, offset</span><br></pre></td></tr></table></figure></p>
<p>精确的标志主节点的数据集版本。<br>当从节点连接到主节点后，他们会使用PSYNC命令发送他们旧的主节点复制ID和对应的已经处理的偏移量。这种方式主节点就能够只发送需要新增的部分。但是如果缓冲区没有足够的积压或者从节点提供的ID已经不可知了，那么完整的同步就会发生：在这种情况下从节点会从零开始复制数据集。<br>下面是一个完全同步工作的详细内容：<br>主节点会开始一个后台保存的进程去生产一个RDB文件。同事它会把从客户端所有接收的写命令保存到缓冲区。当后台保存完成后，这个主节点会把这个数据库文件发送给从节点，从节点将保存到磁盘上，并且将它们加载到内存里面。这个主节点在把发送到缓冲区的所有命令发送给从节点。这是通过流命令和Redis协议本身来处理的。<br>你可以尝试使用telnet来访问。连接这个Redis服务，输入SYNC命令来处理工作。你将会看到大量的转移信息和每个命令接收的情况。实际上SYNC是一个不在使用的旧协议，但是仍然是像后兼容的：它不允许部分重新同步，所以使用PSYNC来代替使用。<br>正如前面所说的，从节点能够在某些原因下自动重新连接主节点。如果主节点接收到了多个从节点的同步请求，它会执行一个单独的保存操作提供给所有的节点服务。</p>
<h2 id="Diskless-replication"><a href="#Diskless-replication" class="headerlink" title="Diskless replication"></a>Diskless replication</h2><p>通常一个完整的重新同步会创建一个RDB文件到磁盘，然后在从磁盘加载相同的RDB给所有的从节点。<br>因为磁盘的读写问题使得主节点有很大的压力。在Redis2.8.18版本开始支持无盘复制。直接通过子进程将RDB发送给其他的从节点，不需要磁盘作为中间存储。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>配置Redis的复制是很简单的事情：只需要执行下面的流程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure></p>
<p>当然你需要替换掉192.168.1.1 6379为你的主节点IP地址（或者主机名）和端口。通过调用<a href="https://redis.io/commands/slaveof" target="_blank" rel="noopener">SLAVEOF</a>命令来让主节点开始同步。<br>还有一些参数作为主节点在内存中执行部分重新同步的优化。可以查看例子文件redis.conf获取更多信息。<br>无盘复制通过激活repl-diskless-sync参数。通过延长启动来等待更多的从节点参与，是通过 repl-diskless-sync-delay参数控制。请参考例子文件redis.conf获取更多信息。</p>
<h2 id="Read-only-slave"><a href="#Read-only-slave" class="headerlink" title="Read-only slave"></a>Read-only slave</h2><p>从Redis2.6版本开始，从节点支持只读模式，默认是被激活的。这个行为的控制在redis.conf文件里通过slave-read-only来控制，能够在运行环境使用 <a href="https://redis.io/commands/config-set" target="_blank" rel="noopener">CONFIG SET</a>来激活或者禁用。<br>Read-only 从节点将拒绝接受所有的写命令，因此给从节点写内容会产生错误。这并不意味着就可以将这些从节点暴露在外网或者客户端使用，因为一些调试命令比如DEBUG或者CONFIG都是被激活的。但是，可以通过使用rename-command指令来达到禁用命令从而保证安全。</p>
<p>You may wonder why it is possible to revert the read-only setting and have slave instances that can be targeted by write operations. While those writes will be discarded if the slave and the master resynchronize or if the slave is restarted, there are a few legitimate use case for storing ephemeral data in writable slaves.<br>For example computing slow Set or Sorted set operations and storing them into local keys is an use case for writable slaves that was observed multiple times.<br>However note that writable slaves before version 4.0 were incapable of expiring keys with a time to live set. This means that if you use EXPIRE or other commands that set a maximum TTL for a key, the key will leak, and while you may no longer see it while accessing it with read commands, you will see it in the count of keys and it will still use memory. So in general mixing writable slaves (previous version 4.0) and keys with TTL is going to create issues.<br>Redis 4.0 RC3 and greater versions totally solve this problem and now writable slaves are able to evict keys with TTL as masters do, with the exceptions of keys written in DB numbers greater than 63 (but by default Redis instances only have 16 databases).<br>所以在Redis4.0版本以后写只能在本地操作，并且不会传播给其他的子从节点。子从节点只会接收来自顶层主节点的复制流信息。例如下面的流程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A ---&gt; B ---&gt; C</span><br></pre></td></tr></table></figure></p>
<p>即使B可写，C也不会看到B写的内容并且将具有与主节点A相同的数据集。</p>
<h2 id="Setting-a-slave-to-authenticate-to-a-master"><a href="#Setting-a-slave-to-authenticate-to-a-master" class="headerlink" title="Setting a slave to authenticate to a master"></a>Setting a slave to authenticate to a master</h2><p>如果你的主节点需要通过密码才可以访问，配置从节点使用密码来进行同步操作是很容易的。<br>使用redis-cli在运行的实例上面这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以把它永久的写到配置文件里面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Allow-writes-only-with-N-attached-replicas"><a href="#Allow-writes-only-with-N-attached-replicas" class="headerlink" title="Allow writes only with N attached replicas"></a>Allow writes only with N attached replicas</h2><p>从Redis2.8版本开始，可以配置一个Redis主节点在至少有N个从节点连接到当前主节点的情况下才允许写操作。<br>但是，因为Redis使用的是异步复制它不保证从节点实际接收到写，所以这种方式总是有可能丢失数据。<br>这是工作的过程：</p>
<ul>
<li>Redis 从节点会每秒去ping主节点，来确认复制流进程。</li>
<li>Redis 主节点会记住最后一次接收到的ping信息。</li>
<li>用户可以配置一个最小数量的从节点，或者最大延迟的秒数<br>如果配置至少为N个从节点，滞后小于M秒，这时候写将会被允许。<br>可以认为是一种尽量保证数据安全的机制。这种情况下，对于给定的数据不能保证一致性，但至少限定在了给定的秒内。<br>如果条件不符合，主节点将会返回错误，而写入不会被接受。<br>该功能有两个配置参数：</li>
<li>min-slaves-to-write <number of="" slaves=""></number></li>
<li>min-slaves-max-lag <number of="" seconds=""><br>更多的信息，请查看例子redis.conf文件。</number></li>
</ul>
<h2 id="How-Redis-replication-deals-with-expires-on-keys"><a href="#How-Redis-replication-deals-with-expires-on-keys" class="headerlink" title="How Redis replication deals with expires on keys"></a>How Redis replication deals with expires on keys</h2><p>Redis expires allow keys to have a limited time to live. Such a feature depends on the ability of an instance to count the time, however Redis slaves correctly replicate keys with expires, even when such keys are altered using Lua scripts.</p>
<p>To implement such a feature Redis cannot rely on the ability of the master and slave to have synchronized clocks, since this is a problem that cannot be solved and would result into race conditions and diverging data sets, Redis使用三种主要的技术复制要过期的key来确保工作:</p>
<ol>
<li>从节点不会去过期一个key，实例会等待主节点去过期这个key。当主节点过期一个key（或者因为LRU被剔除），它将给所有的从节点发送一个<a href="https://redis.io/commands/del" target="_blank" rel="noopener">DEL</a>命令。</li>
<li>因为这个是主节点驱动过期，某些从节点可以在内存里面还是会存在过期的key，因为在这个时间段主节点还没有提供<a href="https://redis.io/commands/del" target="_blank" rel="noopener">DEL</a>命令。处理这个问题，从节点会采用自己的时钟报告这个键不存在。这样就避免了key值过期的情况。实际上，一个缓存片段也能够避免超过时间的项。</li>
<li>During Lua scripts executions no keys expires are performed. As a Lua script runs, conceptually the time in the master is frozen, so that a given key will either exist or not for all the time the script runs. This prevents keys to expire in the middle of a script, and is needed in order to send the same script to the slave in a way that is guaranteed to have the same effects in the data set.</li>
</ol>
<p>一旦从节点被提升为了主节点它将独立运行这些keys，并且不需要旧的主节点的任何帮助。</p>
<h2 id="Configuring-replication-in-Docker-and-NAT"><a href="#Configuring-replication-in-Docker-and-NAT" class="headerlink" title="Configuring replication in Docker and NAT"></a>Configuring replication in Docker and NAT</h2><p>使用Docker,或者其他类型容器的端口映射，或者使用网络地址转换，Redis复制需要一些额外的配置，尤其是使用了Redis Sentinel或者其他系统对主节点 INFO 或者 ROLE命令的输出进行了扫描来发现从节点地址信息。<br>问题是这个ROLE命令，复制的输出信息里面的IP地址可能会因为使用了NAT后与逻辑地址不相同。<br>同样会因为端口映射而导致和redis.conf里面的配置不同。<br>为了解决上面的两个问题，在Redis3.2.2版本里面通过强制指定ip和端口来解决，这两个配置指令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slave-announce-ip 5.5.5.5</span><br><span class="line">slave-announce-port 1234</span><br></pre></td></tr></table></figure></p>
<p>And are documented in the example redis.conf of recent Redis distributions.</p>
<h2 id="The-INFO-and-ROLE-command"><a href="#The-INFO-and-ROLE-command" class="headerlink" title="The INFO and ROLE command"></a>The INFO and ROLE command</h2><p>这两个Redis命令提供了一些关于当前复制参数的信息。<br> One is INFO. If the command is called with the replication argument as INFO replication only information relevant to the replication are displayed. Another more computer-friendly command is ROLE, that provides the replication status of masters and slaves together with their replication offsets, list of connected slaves and so forth.</p>
<h2 id="Partial-resynchronizations-after-restarts-and-failovers"><a href="#Partial-resynchronizations-after-restarts-and-failovers" class="headerlink" title="Partial resynchronizations after restarts and failovers"></a>Partial resynchronizations after restarts and failovers</h2><p>在Redis4.0版本中，当一个实例被提升为主节点之后，它将继续与旧的主节点进行部分内容的同步。所以，从节点会记住旧的复制ID和偏移量。所以通过就的复制ID能够提供积压的信息，这样降低了对数据丢失的概率.</p>
<p>However the new replication ID of the promoted slave will be different, since it constitutes a different history of the data set. For example, the master can return available and can continue accepting writes for some time, so using the same replication ID in the promoted slave would violate the rule that a of replication ID and offset pair identifies only a single data set.</p>
<p>Moreover slaves when powered off gently and restarted, are able to store in the RDB file the information needed in order to resynchronize with their master. This is useful in case of upgrades. When this is needed, it is better to use the SHUTDOWN command in order to perform a save &amp; quit operation on the slave.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/10/11/Redis-Quick-Start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/11/Redis-Quick-Start/" itemprop="url">
                  Redis Quick Start
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-10-11 20:37:26" itemprop="dateCreated datePublished" datetime="2016-10-11T20:37:26+08:00">2016-10-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/10/11/Redis-Quick-Start/" class="leancloud_visitors" data-flag-title="Redis Quick Start">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#8195;&#8195;这是一篇给没有使用过Redis的用户的快速开始文档。阅读这篇文档给你以下的帮助：</p>
<ul>
<li>通过下载和编译Redis去启动服务。</li>
<li>使用redis-cli去访问服务。</li>
<li>通过你的应用程序来使用Redis。</li>
<li>理解Redis是怎样持久化工作的。</li>
<li>更好的去安装Redis。</li>
<li>通过阅读其他资料进一步了解Redis。</li>
</ul>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>推荐通过源码编译安装Redis，只需要GCC compiler and libc就可以工作，不需要其他的依赖。通过包管理器安装的Redis不是最新的版本。<br>你可以通过<a href="http://redis.io/" target="_blank" rel="noopener">redis.io</a>站点去下载最后的Redis版本，或者通过<a href="http://download.redis.io/redis-stable.tar.gz" target="_blank" rel="noopener">http://download.redis.io/redis-stable.tar.gz</a>下载最新的稳定版本。<br>按照下面简单的步骤编译redis:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable.tar.gz</span><br><span class="line">tar xvzf redis-stable.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-stable</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>你可以通过输入make test来构建测试，这是一个可选的步骤。编译后的src目录会出现不同的可执行文件：</p>
<ul>
<li>redis-server 服务本身.</li>
<li>redis-sentinel 高可用工具 (监控和故障转移).</li>
<li>redis-cli 命令行工具来连接Redis。</li>
<li>redis-benchmark 用来检查Redis性能的工具。</li>
<li>redis-check-aof and redis-check-dump 修复数据文件的工具。</li>
</ul>
<p>复制Redis服务和命令行工具到适当的地方，手动执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp src/redis-server /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">sudo cp src/redis-cli /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></p>
<p>或者使用 sudo make install.</p>
<h2 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h2><p>下面的流程我们假设/usr/local/bin在你的PATH环境变量里，所以你在执行这些命令的时候不需要指定完整的路径。</p>
<p>启动Redis服务最简单的方式就是不带任何参数运行redis-server。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server</span><br><span class="line">[28550] 01 Aug 19:29:28 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use 'redis-server /path/to/redis.conf'</span></span><br><span class="line">[28550] 01 Aug 19:29:28 * Server started, Redis version 2.2.12</span><br><span class="line">[28550] 01 Aug 19:29:28 * The server is now ready to accept connections on port 6379</span><br><span class="line">... more logs ...</span><br></pre></td></tr></table></figure></p>
<p>上面的例子里面Redis没有带任何配置文件启动，所有的参数都将使用默认值。如果你启动Redis仅仅只是玩一玩或者作为开发使用，这样就已经可以了，但如果是生产环境的话你应该制定一个配置文件。</p>
<p>在启动Redis的时候使用完整路径携带一个配置文件并且作为第一个参数，像这样：redis-server /etc/redis.conf。你应该使用源码根目录下面的redis.conf作为一个模板来修改你的配置文件。</p>
<h2 id="检查Redis是否在工作"><a href="#检查Redis是否在工作" class="headerlink" title="检查Redis是否在工作"></a>检查Redis是否在工作</h2><p>外部程序与Redis交互使用的是TCP socket和一个具体的协议。这个协议根据不同的程序语言来实现。我们使用Redis提供的一个命令行工具来发送命令给Redis,这个工具叫Redis-cli。第一件事情就是发送一个PING命令来检查Redis是否在工作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></p>
<p>运行redis-cli命令将连接本地的6379端口并发送命令名称给服务器。你可以改变主机和端口，只需要输入–help选项就可以获取使用信息。</p>
<p>另一个有趣的方式是运行一个不带参数的redis-cli：这个程序将开启交互模式，你可以键入不同的命令来查看结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli                                                                </span><br><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">set</span> mykey somevalue</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">"somevalue"</span></span><br></pre></td></tr></table></figure></p>
<p>这样你就可以和Redis交互了。你可以花上15分钟时间来学习<a href="http://redis.io/topics/data-types-intro" target="_blank" rel="noopener">Redis的数据类型</a>，如果你已经知道了这些命令的使用可以跳过阅读。</p>
<h2 id="保护Redis"><a href="#保护Redis" class="headerlink" title="保护Redis"></a>保护Redis</h2><p>默认情况下Redis绑定所有的接口并且不需要认证。如果你的Redis是在一个可以控制的环境里面，受外界的攻击，这样就很好。但是如果Redis暴露在了互联网的话，这就是一个很大的安全问题。如果你不能够百分之百的确保你的环境被妥善的处理，请通过以下步骤检查安全性。</p>
<ol>
<li>确保Redis连接端口（默认是6379，如果你运行Redis是在集群模式下使用的是16379，Sentinel模式是26379）是在防火墙后面，所以外网是不能够连接进来的。</li>
<li>修改配置文件里面的bind指令，只设置成你使用的网络接口，比如设置成回环接口(127.0.0.1)就只能允许同一台机子访问Redis，等等。</li>
<li>使用requirepass选项添加一层额外的安全保护，客户端就必须通过AUTH命令来认证。</li>
<li>如果你的环境必须要加密处理的话，就使用<a href="http://www.tarsnap.com/spiped.html" target="_blank" rel="noopener">spiped</a>或者其他的SSL软件来加密服务器和客户端之间的传输。</li>
</ol>
<p>Redis在没有任何安全保护的情况下暴露在外网是很容易做到的，所以你要确保至少有一个保护层，可以尝试在防火墙中和外部通过redis-cli去连接服务来证明你的安全性。</p>
<h2 id="在你的应用程序里面使用Redis"><a href="#在你的应用程序里面使用Redis" class="headerlink" title="在你的应用程序里面使用Redis"></a>在你的应用程序里面使用Redis</h2><p>通过使用Redis的命令行工具还不够，我们想通过程序来交互，你需要下载你的程序语言对应的客户端库，你可以在<a href="http://redis.io/clients" target="_blank" rel="noopener">这里</a>找到不同语言对应的客户端库信息。</p>
<p>如果你恰好使用的是Ruby语言开发的程序，我们建议使用<a href="https://github.com/redis/redis-rb" target="_blank" rel="noopener">Redis-rb</a> client。你可以使用命令gem install redis去安装redis。</p>
<p>这些指令是在Ruby环境下的，但其他语言的库看起来都差不多：创建一个Redis对象并且执行命令，一个简单的Ruby例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; require <span class="string">'rubygems'</span></span><br><span class="line">=&gt; <span class="literal">false</span></span><br><span class="line">&gt;&gt; require <span class="string">'redis'</span></span><br><span class="line">=&gt; <span class="literal">true</span></span><br><span class="line">&gt;&gt; r = Redis.new</span><br><span class="line">=&gt; <span class="comment">#&lt;Redis client v2.2.1 connected to redis://127.0.0.1:6379/0 (Redis v2.3.8)&gt;</span></span><br><span class="line">&gt;&gt; r.ping</span><br><span class="line">=&gt; <span class="string">"PONG"</span></span><br><span class="line">&gt;&gt; r.set(<span class="string">'foo'</span>,<span class="string">'bar'</span>)</span><br><span class="line">=&gt; <span class="string">"OK"</span></span><br><span class="line">&gt;&gt; r.get(<span class="string">'foo'</span>)</span><br><span class="line">=&gt; <span class="string">"bar"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>你可以学习 <a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">how Redis persistence works on this page</a>, 然而我们要理解默认启动, 如果你使用的是默认配置启动的Redis,Redis 会自动的保存数据集(例如5分钟后，或者至少有100次的修改),如果你想你的数据库持久化并且在重启后重新加载数据， 就需要手动调用SAVE命令强制设置一个数据快照，否则请使用SHUTDOWN命令来关掉数据库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli shutdown</span><br></pre></td></tr></table></figure></p>
<p>这种方式Redis将在退出之前将数据保存到磁盘。强烈建议阅读<a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">持久化工作</a></p>
<h2 id="更好的安装Redis"><a href="#更好的安装Redis" class="headerlink" title="更好的安装Redis"></a>更好的安装Redis</h2><p>通过命令行运行Redis仅仅是在开发环境。然而，你的实际程序是运行在一个真实的服务器上。你有两种不同的选择：</p>
<ul>
<li>使用screen运行Redis。</li>
<li>使用初始化脚本来启动Redis，在重启后会重新开始。</li>
</ul>
<p>建议使用初始化脚本来安装，我们假设已经复制了redis-server和redis-cli到/usr/local/bin目录下面。</p>
<ul>
<li><p>创建一个目录来存储你的Redis配置和你的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/redis</span><br><span class="line">sudo mkdir /var/redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>在utils目录下面找到初始化脚本复制到/etc/init.d目录中，例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp utils/redis_init_script /etc/init.d/redis_6379</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑初始化脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/init.d/redis_6379</span><br></pre></td></tr></table></figure>
<p>确保修改的redis端口关联到你使用的端口。pid文件和配置文件都依赖这个端口。</p>
</li>
<li>在你的根目录下面复制模板配置文件到/etc/redis下面，使用端口命名文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>在/var/redis/里面创建一个目录作为数据和工作的目录：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/redis/6379</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑配置文件，确保执行了以下更改：</li>
</ul>
<ul>
<li>设置daemonize为yes(默认是no)</li>
<li>设置pidfile路径为/var/run/redis_6379.pid（修改端口时需要设置）</li>
<li>修改端口，在我们的例子里面使用的是默认端口6379.</li>
<li>设置你的日志级别loglevel。</li>
<li>设置logfile路径为/var/log/redis_6379.log</li>
<li><p>设置dir数据目录为 /var/redis/6379 (非常重要的一步！)</p>
</li>
<li><p>最后修改初始化脚本文件的运行级别，ubuntu执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d redis_6379 defaults</span><br></pre></td></tr></table></figure>
<p> centos执行以下命令,文件开头添加chkconfig：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/redis_6379</span><br><span class="line"><span class="comment"># chkconfig:  2345 90 10</span></span><br><span class="line">chkconfig redis_6379 on</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>你可以尝试运行你的实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/redis_6379 start</span><br></pre></td></tr></table></figure></p>
<p>确保按照预期的执行：</p>
<ul>
<li>尝试使用redis-cli去ping你的实例。</li>
<li>使用redis-cli save命令测试保存并且检查dump文件是否保存到了/var/redis/6379（你应该会找到一个dump.rdb文件）。</li>
<li>检查你的redis实例是否正确的记录了日志。</li>
<li>如果它是一台新的机器，你可以在没有问题的情况下尝试它，确保重启后一切仍在工作。</li>
</ul>
<p>注意：我们在这个例子里面跳过了很多配置参数，务必阅读例子中的redis.conf文件，你也可以在这个网站的其他文档上找到更多的信息。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/10/10/MySql-Replication-Keepalived/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/10/MySql-Replication-Keepalived/" itemprop="url">
                  MySQL Replication+Keepalived
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-10-10 21:37:26" itemprop="dateCreated datePublished" datetime="2016-10-10T21:37:26+08:00">2016-10-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-18 09:07:26" itemprop="dateModified" datetime="2019-01-18T09:07:26+08:00">2019-01-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/10/10/MySql-Replication-Keepalived/" class="leancloud_visitors" data-flag-title="MySQL Replication+Keepalived">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#8195;&#8195;MySql官网提供了2种复制方案，一种是基于日志文件来实现复制，一种是基于GTIDs来实现复制，这篇文章采用第一种来试验，结合keepalived完成高可用。试验环境如下：</p>
<table>
<thead>
<tr>
<th>系统环境</th>
<th>IP地址</th>
<th style="text-align:center">节点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.92</td>
<td style="text-align:center">Master</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.93</td>
<td style="text-align:center">Slave(用于备份服务器)</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.94</td>
<td style="text-align:center">VIP</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.17</td>
<td style="text-align:center">Client</td>
</tr>
</tbody>
</table>
<h2 id="MySql安装"><a href="#MySql安装" class="headerlink" title="MySql安装"></a>MySql安装</h2><p>&#8195;&#8195;本文采用离线安装包的方式安装mysql服务。使用的版本是5.7.13，<a href="https://downloads.mysql.com/archives/community/" target="_blank" rel="noopener">下载地址</a>,下载的文件清单：</p>
<ol>
<li>mysql-community-client-5.7.13-1.el6.x86_64.rpm </li>
<li>mysql-community-common-5.7.13-1.el6.x86_64.rpm </li>
<li>mysql-community-libs-5.7.13-1.el6.x86_64.rpm </li>
<li>mysql-community-server-5.7.13-1.el6.x86_64.rpm</li>
</ol>
<p>Master和Slave节点都安装mysql，执行以下操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost scripts]<span class="comment"># ntpdate -u ntp.api.bz</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -qa | grep mysql</span></span><br><span class="line">mysql-server-5.1.71-1.el6.x86_64</span><br><span class="line">mysql-libs-5.1.71-1.el6.x86_64</span><br><span class="line">mysql-5.1.71-1.el6.x86_64</span><br><span class="line">qt-mysql-4.6.2-26.el6_4.x86_64</span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -e --nodeps mysql-server-5.1.71-1.el6.x86_64</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -e --nodeps mysql-libs-5.1.71-1.el6.x86_64</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -e --nodeps mysql-5.1.71-1.el6.x86_64</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -e --nodeps qt-mysql-4.6.2-26.el6_4.x86_64</span></span><br><span class="line">[root@localhost mysql]<span class="comment"># ls</span></span><br><span class="line">mysql-community-client-5.7.13-1.el6.x86_64.rpm  mysql-community-common-5.7.13-1.el6.x86_64.rpm  mysql-community-libs-5.7.13-1.el6.x86_64.rpm  mysql-community-server-5.7.13-1.el6.x86_64.rpm</span><br><span class="line">[root@localhost mysql]<span class="comment"># rpm -ivh mysql-community-common-5.7.13-1.el6.x86_64.rpm</span></span><br><span class="line">warning: mysql-community-common-5.7.13-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                <span class="comment">########################################### [100%]</span></span><br><span class="line">   1:mysql-community-common <span class="comment">########################################### [100%]</span></span><br><span class="line">[root@localhost mysql]<span class="comment"># rpm -ivh mysql-community-libs-5.7.13-1.el6.x86_64.rpm</span></span><br><span class="line">warning: mysql-community-libs-5.7.13-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                <span class="comment">########################################### [100%]</span></span><br><span class="line">   1:mysql-community-libs   <span class="comment">########################################### [100%]</span></span><br><span class="line">[root@localhost mysql]<span class="comment"># rpm -ivh mysql-community-client-5.7.13-1.el6.x86_64.rpm</span></span><br><span class="line">warning: mysql-community-client-5.7.13-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                <span class="comment">########################################### [100%]</span></span><br><span class="line">   1:mysql-community-client <span class="comment">########################################### [100%]</span></span><br><span class="line">[root@localhost mysql]<span class="comment"># rpm -ivh mysql-community-server-5.7.13-1.el6.x86_64.rpm</span></span><br><span class="line">warning: mysql-community-server-5.7.13-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                <span class="comment">########################################### [100%]</span></span><br><span class="line">   1:mysql-community-server <span class="comment">########################################### [100%]</span></span><br></pre></td></tr></table></figure></p>
<p>启动mysql服务,获取root初始化密码,测试成功后停止mysql：<br>[root@localhost lib]# service mysqld start<br>[root@localhost lib]# service mysqld status<br>[root@localhost lib]# grep ‘temporary password’ /var/log/mysqld.log<br>[root@localhost lib]# service mysqld stop</p>
<p>mysql服务就这样安装好了，下面接着进行服务的配置：</p>
<ol>
<li>数据库目录的配置，默认是指向的/var/lib/mysql,这个时候你要注意当前路径所在的磁盘空间是否足够：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># df -hl</span></span><br><span class="line">Filesystem                      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/vg_livedvd-lv_root   36G  5.7G   30G  17% /</span><br><span class="line">tmpfs                           939M     0  939M   0% /dev/shm</span><br><span class="line">/dev/sda1                       485M   40M  421M   9% /boot</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Master的配置文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>-error=/var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line"><span class="comment">#replication</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line">sync_binlog=1</span><br><span class="line">replicate-wild-ignore-table=mysql.%</span><br><span class="line">replicate-wild-ignore-table=<span class="built_in">test</span>.%</span><br><span class="line">replicate-wild-ignore-table=information_schema.%</span><br><span class="line">replicate-wild-ignore-table=performance_schema.%</span><br><span class="line">replicate-wild-ignore-table=sys.%</span><br><span class="line">relay-log=mysql-relay-bin</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></p>
<p>Slave的配置内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>-error=/var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"><span class="comment">#replication</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line">sync_binlog=1</span><br><span class="line">replicate-wild-ignore-table=mysql.%</span><br><span class="line">replicate-wild-ignore-table=<span class="built_in">test</span>.%</span><br><span class="line">replicate-wild-ignore-table=information_schema.%</span><br><span class="line">replicate-wild-ignore-table=performance_schema.%</span><br><span class="line">replicate-wild-ignore-table=sys.%</span><br><span class="line">relay-log=mysql-relay-bin</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></p>
<p>编辑文件/etc/sysconfig/iptables, 打开端口3306:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost data]<span class="comment"># vim /etc/sysconfig/iptables</span></span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br><span class="line">[root@localhost data]<span class="comment"># /etc/init.d/iptables restart</span></span><br><span class="line">iptables: Setting chains to policy ACCEPT: filter          [  OK  ]</span><br><span class="line">iptables: Flushing firewall rules:                         [  OK  ]</span><br><span class="line">iptables: Unloading modules:                               [  OK  ]</span><br><span class="line">iptables: Applying firewall rules:                         [  OK  ]</span><br></pre></td></tr></table></figure></p>
<p>启动mysql服务，修改mysql的默认密码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># grep 'password' /var/log/mysqld.log </span></span><br><span class="line">[root@localhost opt]<span class="comment"># service mysqld start</span></span><br><span class="line">Initializing MySQL database:                               [  OK  ]</span><br><span class="line">Installing validate password plugin:                       [  OK  ]</span><br><span class="line">Starting mysqld:                                           [  OK  ]</span><br><span class="line">[root@localhost opt]<span class="comment"># grep 'temporary password' /var/log/mysqld.log</span></span><br><span class="line">mysql&gt; ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'Admin@2016'</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="Master配置"><a href="#Master配置" class="headerlink" title="Master配置"></a>Master配置</h2><p>1.提供一个slave可以复制的账号,ip地址根据实际情况修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER <span class="string">'repl'</span>@<span class="string">'192.168.1.93'</span> IDENTIFIED BY <span class="string">'Admin@2016'</span>;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'192.168.1.93'</span>;</span><br><span class="line">mysql&gt; grant all on *.* to root@<span class="string">'192.168.1.17'</span> identified by <span class="string">'Admin@2016'</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></p>
<p>2.去Slave数据库查询坐标信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000003 |      1304 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>3.命令行里面设置slave配置信息，注意日志文件的起点(Master和Slave都执行了1和2步骤才执行该步骤):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO \</span><br><span class="line">MASTER_HOST=<span class="string">'192.168.1.93'</span>, \</span><br><span class="line">MASTER_PORT=3306, \</span><br><span class="line">MASTER_USER=<span class="string">'repl'</span>, \</span><br><span class="line">MASTER_PASSWORD=<span class="string">'Admin@2016'</span>, \</span><br><span class="line">MASTER_LOG_FILE=<span class="string">'mysql-bin.000003'</span>, \</span><br><span class="line">MASTER_LOG_POS=1304;</span><br></pre></td></tr></table></figure></p>
<h2 id="Slave配置"><a href="#Slave配置" class="headerlink" title="Slave配置"></a>Slave配置</h2><p>1.提供一个Master可以复制的账号,ip地址根据实际情况修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER <span class="string">'repl'</span>@<span class="string">'192.168.1.92'</span> IDENTIFIED BY <span class="string">'Admin@2016'</span>;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'192.168.1.92'</span>;</span><br><span class="line">mysql&gt; grant all on *.* to root@<span class="string">'192.168.1.17'</span> identified by <span class="string">'Admin@2016'</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></p>
<p>2.去Master数据库查询坐标信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000003 |     1304 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>3.命令行里面设置Master配置信息，注意日志文件的起点(Master和Slave都执行了1和2步骤才执行该步骤):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO \</span><br><span class="line">MASTER_HOST=<span class="string">'192.168.1.92'</span>, \</span><br><span class="line">MASTER_PORT=3306, \</span><br><span class="line">MASTER_USER=<span class="string">'repl'</span>, \</span><br><span class="line">MASTER_PASSWORD=<span class="string">'Admin@2016'</span>, \</span><br><span class="line">MASTER_LOG_FILE=<span class="string">'mysql-bin.000003'</span>, \</span><br><span class="line">MASTER_LOG_POS=1304;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试同步效果"><a href="#测试同步效果" class="headerlink" title="测试同步效果"></a>测试同步效果</h2><p>两台服务启动slave，查看状态Slave_IO_Running: Yes和Slave_SQL_Running: Yes,并且没有error错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                  Master_Host: 192.168.1.93</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000003</span><br><span class="line">          Read_Master_Log_Pos: 1304</span><br><span class="line">               Relay_Log_File: mysql-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000003</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: mysql.%,<span class="built_in">test</span>.%,information_schema.%</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 1304</span><br><span class="line">              Relay_Log_Space: 527</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 2</span><br><span class="line">                  Master_UUID: a811e6e5-918d-11e7-9670-000c29358af8</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has <span class="built_in">read</span> all relay <span class="built_in">log</span>; waiting <span class="keyword">for</span> more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;show processList\G;</span><br></pre></td></tr></table></figure></p>
<p>主库创建数据库,创建表，插入数据，去从库看一下是否同步:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create database test1;</span><br><span class="line">use test1;</span><br><span class="line">CREATE TABLE `catalog` (</span><br><span class="line">  `id` varchar(32) NOT NULL,</span><br><span class="line">  `parent_id` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">INSERT INTO `catalog` VALUES (<span class="string">'01'</span>, <span class="string">'A'</span>, <span class="string">'农业'</span>);</span><br><span class="line">INSERT INTO `catalog` VALUES (<span class="string">'011'</span>, <span class="string">'01'</span>, <span class="string">'谷物种植'</span>);</span><br></pre></td></tr></table></figure></p>
<p>从库创建数据库,创建表，插入数据，去主库看一下是否同步:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create database test2;</span><br><span class="line">use test2;</span><br><span class="line">CREATE TABLE `catalog` (</span><br><span class="line">  `id` varchar(32) NOT NULL,</span><br><span class="line">  `parent_id` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">INSERT INTO `catalog` VALUES (<span class="string">'01'</span>, <span class="string">'A'</span>, <span class="string">'农业2'</span>);</span><br><span class="line">INSERT INTO `catalog` VALUES (<span class="string">'011'</span>, <span class="string">'01'</span>, <span class="string">'谷物种植2'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果两边看到的内容一致，表示主主复制关系没问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test1              |</span><br><span class="line">| test2              |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test2.catalog;</span><br><span class="line">+-----+-----------+---------------+</span><br><span class="line">| id  | parent_id | name          |</span><br><span class="line">+-----+-----------+---------------+</span><br><span class="line">| 01  | A         | 农业2         |</span><br><span class="line">| 011 | 01        | 谷物种植2     |</span><br><span class="line">+-----+-----------+---------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="系统调优"><a href="#系统调优" class="headerlink" title="系统调优"></a>系统调优</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># modprobe bridge</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "modprobe bridge" &gt;&gt;/etc/rc.local</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/security/limits.conf</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc unlimited</span><br><span class="line">* hard nproc unlimited</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/security/limits.d/90-nproc.conf </span></span><br><span class="line">*          soft    nproc     unlimited</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>
<h2 id="LVS安装"><a href="#LVS安装" class="headerlink" title="LVS安装"></a>LVS安装</h2><p>检查linux内核是否集成lvs模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># modprobe -l | grep ipvs</span></span><br></pre></td></tr></table></figure></p>
<p>第一种通过lvs源码安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install ipvsadm -y</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ipvsadm -v</span></span><br><span class="line">ipvsadm v1.26 2008/5/15 (compiled with popt and IPVS v1.2.1)</span><br></pre></td></tr></table></figure></p>
<p>第二种通过源码编译安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]<span class="comment"># wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz</span></span><br><span class="line">[root@localhost ipvsadm-1.26]<span class="comment"># tar zxf ipvsadm-1.26.tar.gz</span></span><br><span class="line">[root@localhost ipvsadm-1.26]<span class="comment"># make</span></span><br><span class="line">[root@localhost ipvsadm-1.26]<span class="comment"># make install</span></span><br></pre></td></tr></table></figure></p>
<p>开启路由转发功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo "modprobe bridge" &gt;&gt;/etc/rc.local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "echo 1 &gt; /proc/sys/net/ipv4/ip_forward" &gt;&gt; /etc/rc.local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">[root@localhost ~]<span class="comment"># modprobe ip_vs</span></span><br><span class="line">[root@localhost ~]<span class="comment"># modprobe ip_vs_wrr</span></span><br><span class="line">[root@localhost ~]<span class="comment"># lsmod | grep ip_vs</span></span><br><span class="line">ip_vs_wrr               2179  1 </span><br><span class="line">ip_vs                 126705  3 ip_vs_wrr</span><br><span class="line">libcrc32c               1246  1 ip_vs</span><br><span class="line">ipv6                  336368  47 ip_vs,bridge,ip6t_REJECT,nf_conntrack_ipv6,nf_defrag_ipv6</span><br></pre></td></tr></table></figure></p>
<h2 id="Keepalived安装"><a href="#Keepalived安装" class="headerlink" title="Keepalived安装"></a>Keepalived安装</h2><p>Master和Slave都执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install keepalived -y</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig keepalived on</span></span><br><span class="line">[root@localhost ~]<span class="comment"># keepalived -v</span></span><br><span class="line">Keepalived v1.2.13 (03/19,2015)</span><br></pre></td></tr></table></figure></p>
<p>第二种安装方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]<span class="comment"># yum install -y gcc gcc-c++ makepcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel libnfnetlink-devel openssl-devel popt-static</span></span><br><span class="line">[root@localhost opt]<span class="comment"># wget http://www.keepalived.org/software/keepalived-1.2.24.tar.gz</span></span><br><span class="line">[root@localhost opt]<span class="comment"># tar zxf keepalived-1.2.24.tar.gz</span></span><br><span class="line">[root@localhost opt]<span class="comment"># cd keepalived-1.2.24</span></span><br><span class="line">[root@localhost]<span class="comment"># ./configure --prefix=/usr/local/keepalived</span></span><br><span class="line">[root@localhost]<span class="comment"># make &amp;&amp; make install</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/sbin/keepalived /usr/sbin/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/keepalived /etc/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod +x /usr/local/keepalived/etc/rc.d/init.d/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --add keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig keepalived on</span></span><br></pre></td></tr></table></figure></p>
<p>创建mysql_down监控脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /etc/keepalived/scripts</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/scripts/mysql_down.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">service keepalived stop</span><br><span class="line">[root@master ~]<span class="comment"># chmod +x /etc/keepalived/scripts/mysql_down.sh</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Master节点配置"><a href="#Master节点配置" class="headerlink" title="Master节点配置"></a>Master节点配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from mysql_master@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id MYSQL-HA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 59</span><br><span class="line">    priority 150</span><br><span class="line">    advert_int 1</span><br><span class="line">    nopreempt</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.94/24 dev eth0 scope global label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.1.94 3306 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo wrr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.1.92 3306 &#123;</span><br><span class="line">        notify_down /etc/keepalived/scripts/mysql_down.sh</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Slave-节点配置"><a href="#Slave-节点配置" class="headerlink" title="Slave 节点配置"></a>Slave 节点配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from mysql_slave@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id MYSQL-HA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 59</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.94/24 dev eth0 scope global label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.1.94 3306 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo wrr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.1.93 3306 &#123;</span><br><span class="line">        notify_down /etc/keepalived/scripts/mysql_down.sh</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/sysconfig/iptables</span></span><br><span class="line">-A INPUT -p vrrp -j ACCEPT</span><br></pre></td></tr></table></figure>
<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>手动启动服务器试试正常不：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@master~]<span class="comment"># service keepalived start</span></span><br><span class="line">Starting keepalived:                                       [  OK  ]</span><br><span class="line">[root@master ~]<span class="comment"># ip addr show eth0</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 1000</span><br><span class="line">    link/ether 00:0c:29:62:98:c0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.92/24 brd 192.168.1.255 scope global eth0</span><br><span class="line">    inet 192.168.1.94/24 scope global secondary eth0:0</span><br><span class="line">    inet6 fe80::20c:29ff:fe62:98c0/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line">[root@slave ~]<span class="comment"># service keepalived start</span></span><br><span class="line">Starting keepalived:                                       [  OK  ]</span><br><span class="line">[root@localhost ~]<span class="comment"># ip addr show eth0</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 1000</span><br><span class="line">    link/ether 00:0c:29:35:8a:f8 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.93/24 brd 192.168.1.255 scope global eth0</span><br><span class="line">    inet6 fe80::20c:29ff:fe35:8af8/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></p>
<p>先修改一下主机名信息,重启服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/sysconfig/network</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/hosts</span></span><br></pre></td></tr></table></figure></p>
<p>测试故障转移，正常情况下，客户端连接的是Master节点,在Client机子上进行下面测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'hostname%'</span>;</span><br><span class="line">+---------------+------------------+</span><br><span class="line">| Variable_name | Value            |</span><br><span class="line">+---------------+------------------+</span><br><span class="line">| hostname      | localhost.master |</span><br><span class="line">+---------------+------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p>
<p>此时停掉Master后，在执行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'hostname%'</span>;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| hostname      | localhost.slave |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p>
<p>可以测试在Slave添加一条数据，然后在恢复Master，查询该数据是否存在.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/29/RabbitMQ-Keepalived/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/29/RabbitMQ-Keepalived/" itemprop="url">
                  RabbitMQ Keepalived
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-29 22:37:26" itemprop="dateCreated datePublished" datetime="2016-09-29T22:37:26+08:00">2016-09-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/29/RabbitMQ-Keepalived/" class="leancloud_visitors" data-flag-title="RabbitMQ Keepalived">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><table>
<thead>
<tr>
<th>系统环境</th>
<th>IP地址</th>
<th>主机名</th>
<th style="text-align:center">节点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.92</td>
<td>rabbit1</td>
<td style="text-align:center">Master</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.93</td>
<td>rabbit2</td>
<td style="text-align:center">Slave</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.95</td>
<td></td>
<td style="text-align:center">VIP</td>
</tr>
<tr>
<td>CentOS6.5</td>
<td>192.168.1.17</td>
<td></td>
<td style="text-align:center">Client</td>
</tr>
</tbody>
</table>
<p><strong>主机名设置</strong><br>修改92的主机名为rabbit1,93的主机名为rabbit2：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]<span class="comment"># vim /etc/sysconfig/network</span></span><br><span class="line">[root@localhost opt]<span class="comment"># vim /etc/hosts</span></span><br><span class="line">192.168.1.92    rabbit1</span><br><span class="line">192.168.1.93    rabbit2</span><br><span class="line">[root@localhost opt]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure></p>
<p><strong>SSH设置</strong></p>
<p>2台机子执行以下操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit1 ~]<span class="comment"># ssh-keygen</span></span><br></pre></td></tr></table></figure></p>
<p>rabbit1机子执行以下操作:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit1 ~]<span class="comment"># cp ~/.ssh/id_rsa.pub ~/.ssh/authorized_keys</span></span><br><span class="line">[root@rabbit1 ~]<span class="comment"># ssh root@rabbit2 "cat ~/.ssh/id_rsa.pub" &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line">[root@rabbit1 ~]<span class="comment"># cat ~/.ssh/authorized_keys</span></span><br><span class="line">[root@rabbit1 ~]<span class="comment"># scp ~/.ssh/authorized_keys root@rabbit2:~/.ssh/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><p>参考文章 <a href="http://cjoop.top/2016/09/25/RabbitMQ-Install-on-RPM-based-Linux/">RabbitMQ Install on RPM-based Linux</a>安装好RabbitMQ.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://packages.erlang-solutions.com/erlang/esl-erlang/FLAVOUR_1_general/esl-erlang_19.1.5~centos~6_amd64.rpm</span><br><span class="line">$ wget</span><br><span class="line">https://github.com/jasonmcintosh/esl-erlang-compat/releases/download/1.1.1/esl-erlang-compat-18.1-1.noarch.rpm</span><br><span class="line">$ yum -y install unixODBC wxGTK wxGTK-gl lksctp-tools openssl</span><br><span class="line">$ rpm -ivh esl-erlang_19.1.5~centos~6_amd64.rpm</span><br><span class="line">$ rpm -ivh esl-erlang-compat-18.1-1.noarch.rpm</span><br><span class="line">$ erl -version</span><br><span class="line">Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 8.1</span><br><span class="line">$ wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</span><br><span class="line">$ wget –no-cache http://www.convirture.com/repos/definitions/rhel/6.x/convirt.repo -O /etc/yum.repos.d/convirt.repo</span><br><span class="line">$ yum -y install socat</span><br><span class="line">$ rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p><strong>安装管理插件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
<p><strong>防火墙设置</strong></p>
<p>rabbitmq一共有以下端口被使用，根据实际情况打开端口。</p>
<p>4369 (epmd), 25672 (Erlang distribution)<br>5672, 5671 (AMQP 0-9-1 without and with TLS)<br>15672 (if management plugin is enabled)<br>61613, 61614 (if STOMP is enabled)<br>1883, 8883 (if MQTT is enabled)<br>15674 (WEB-STOMP)<br>编辑文件/etc/sysconfig/iptables,打开端口5672,5671,15672,4369,25672, 61613, 61614:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 5671 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 5672 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 15672 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 4369 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 25672 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 61613 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 61614 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 15674 -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>重启防火墙<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service iptables restart</span><br></pre></td></tr></table></figure></p>
<p>启动服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service rabbitmq-server start</span><br></pre></td></tr></table></figure></p>
<p><strong>管理员设置</strong></p>
<p>访问页面<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#" target="_blank" rel="noopener">http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#</a> 讲解了各种命令，这里使用user命令添加管理员：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rabbitmqctl add_user admin admin123</span><br><span class="line">Creating user <span class="string">"admin"</span> ...</span><br><span class="line">$ rabbitmqctl set_user_tags admin administrator</span><br><span class="line">Setting tags <span class="keyword">for</span> user <span class="string">"admin"</span> to [administrator] ...</span><br></pre></td></tr></table></figure></p>
<p>访问web管理页面：<a href="http://192.168.1.92:15672,输入账号和密码测试登陆" target="_blank" rel="noopener">http://192.168.1.92:15672,输入账号和密码测试登陆</a>.</p>
<p>复制var/lib/rabbitmq/.erlang.cookie到93主机上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit1 ~]<span class="comment"># scp /var/lib/rabbitmq/.erlang.cookie root@rabbit2:/var/lib/rabbitmq/</span></span><br></pre></td></tr></table></figure></p>
<p>检查erlang.cookie是否一致。必须保持一致的cookie。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit1 ~]<span class="comment"># cat /var/lib/rabbitmq/.erlang.cookie </span></span><br><span class="line">PHKQIFQEBDKASNQJOJKR</span><br><span class="line">[root@rabbit2 ~]<span class="comment"># cat /var/lib/rabbitmq/.erlang.cookie </span></span><br><span class="line">PHKQIFQEBDKASNQJOJKR</span><br></pre></td></tr></table></figure></p>
<p>重新启动服务,如果你复制了cookie后不能够重启，那你就重启系统吧：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit2 ~]<span class="comment"># service rabbitmq-server start</span></span><br></pre></td></tr></table></figure></p>
<p>查看各自的集群状态信息,应该都只有自己的节点信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit1 ~]<span class="comment"># rabbitmqctl cluster_status</span></span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;<span class="string">"rabbit@rabbit1"</span>&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;]&#125;]</span><br><span class="line"></span><br><span class="line">[root@rabbit2 ~]<span class="comment"># rabbitmqctl cluster_status</span></span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;<span class="string">"rabbit@rabbit2"</span>&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@rabbit2,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure></p>
<p>将rabbit1，rabbit2组成集群环境。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit2 ~]<span class="comment"># rabbitmqctl stop_app</span></span><br><span class="line">Stopping node rabbit@rabbit2 ...</span><br><span class="line">[root@rabbit2 ~]<span class="comment"># rabbitmqctl join_cluster rabbit@rabbit1</span></span><br><span class="line">Clustering node rabbit@rabbit2 with rabbit@rabbit1 ... </span><br><span class="line">[root@rabbit2 ~]<span class="comment"># rabbitmqctl start_app</span></span><br><span class="line">Starting node rabbit@rabbit2 ...</span><br></pre></td></tr></table></figure></p>
<p>浏览器访问地址：192.168.1.92:15672,看到有2个节点信息，说明成功集群.</p>
<p>接下来在任意节点上设置对所有的队列进行镜像处理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@rabbit2 ~]<span class="comment"># rabbitmqctl set_policy ha-all "^" '&#123;"ha-mode":"all","ha-sync-mode":"automatic"&#125;'</span></span><br><span class="line">Setting policy <span class="string">"ha-all"</span> <span class="keyword">for</span> pattern <span class="string">"^"</span> to <span class="string">"&#123;\"ha-mode\":\"all\"&#125;"</span> with priority <span class="string">"0"</span> ...</span><br></pre></td></tr></table></figure></p>
<h2 id="LVS安装"><a href="#LVS安装" class="headerlink" title="LVS安装"></a>LVS安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install ipvsadm -y</span><br><span class="line">$ ipvsadm -v</span><br><span class="line">ipvsadm v1.26 2008/5/15 (compiled with popt and IPVS v1.2.1)</span><br></pre></td></tr></table></figure>
<p>检查linux内核是否集成lvs模块,开启路由转发功能,以及ip_vs模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe -l | grep ipvs</span><br><span class="line">$ <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"echo 1 &gt; /proc/sys/net/ipv4/ip_forward"</span> &gt;&gt; /etc/rc.local</span><br><span class="line">$ modprobe ip_vs</span><br><span class="line">$ modprobe ip_vs_wrr</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"modprobe ip_vs"</span> &gt;&gt; /etc/rc.local </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"modprobe ip_vs_wrr"</span> &gt;&gt; /etc/rc.local</span><br><span class="line">$ lsmod | grep ip_vs</span><br><span class="line">ip_vs_wrr               2179  1 </span><br><span class="line">ip_vs                 126705  3 ip_vs_wrr</span><br><span class="line">libcrc32c               1246  1 ip_vs</span><br><span class="line">ipv6                  336368  47 ip_vs,bridge,ip6t_REJECT,nf_conntrack_ipv6,nf_defrag_ipv6</span><br></pre></td></tr></table></figure></p>
<h2 id="keepalived安装"><a href="#keepalived安装" class="headerlink" title="keepalived安装"></a>keepalived安装</h2><p>以下是Master和Slave都要进行的操作：<br>从官网下载源码包 <a href="http://www.keepalived.org/download.html" target="_blank" rel="noopener">http://www.keepalived.org/download.html</a> ,安装相应的依赖库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]<span class="comment"># yum install -y gcc gcc-c++ makepcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel libnfnetlink-devel openssl-devel popt-static</span></span><br><span class="line">[root@localhost]<span class="comment"># yum update glib* -y</span></span><br><span class="line">[root@localhost opt]<span class="comment"># wget http://www.keepalived.org/software/keepalived-1.2.24.tar.gz</span></span><br><span class="line">[root@localhost opt]<span class="comment"># tar zxf keepalived-1.2.24.tar.gz</span></span><br><span class="line">[root@localhost opt]<span class="comment"># cd keepalived-1.2.24</span></span><br><span class="line">[root@localhost]<span class="comment"># ./configure --prefix=/usr/local/keepalived</span></span><br><span class="line">[root@localhost]<span class="comment"># make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></p>
<p>创建keepalived服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/sbin/keepalived /usr/sbin/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln -s /usr/local/keepalived/etc/keepalived /etc/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod +x /usr/local/keepalived/etc/rc.d/init.d/keepalived</span></span><br><span class="line">[root@localhost ~]<span class="comment"># keepalived -v</span></span><br></pre></td></tr></table></figure></p>
<h3 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     jun.chen@cyberkey.cn</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from rabbitmq_master@cyberkey.cn</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id RABBITMQ-HA</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_rabbitmq &#123;</span><br><span class="line">    script <span class="string">"rabbitmqctl status"</span></span><br><span class="line">    interval 2</span><br><span class="line">    timeout 4</span><br><span class="line">    weight -100</span><br><span class="line">    fall 2</span><br><span class="line">    rise 1</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 56</span><br><span class="line">    priority 200</span><br><span class="line">    advert_int 1</span><br><span class="line">    nopreempt</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.95/24 dev eth0 scope global label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_rabbitmq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slave配置"><a href="#slave配置" class="headerlink" title="slave配置"></a>slave配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     jun.chen@cyberkey.cn</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from rabbitmq_slave@cyberkey.cn</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id RABBITMQ-HA</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_rabbitmq &#123;</span><br><span class="line">    script <span class="string">"rabbitmqctl status"</span></span><br><span class="line">    interval 2</span><br><span class="line">    timeout 4</span><br><span class="line">    weight -100</span><br><span class="line">    fall 2</span><br><span class="line">    rise 1</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 56</span><br><span class="line">    priority 150</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.95/24 dev eth0 scope global label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_rabbitmq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysconfig/iptables</span><br><span class="line">-A INPUT -p vrrp -j ACCEPT</span><br><span class="line">$ service iptables restart</span><br></pre></td></tr></table></figure>
<h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>启动master和slave的keepalived，尝试手动停止rabbitmq-server进行切换测试。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/28/LVS-Algo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/28/LVS-Algo/" itemprop="url">
                  LVS调度算法介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-28 21:37:26" itemprop="dateCreated datePublished" datetime="2016-09-28T21:37:26+08:00">2016-09-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/LVS/" itemprop="url" rel="index"><span itemprop="name">LVS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/28/LVS-Algo/" class="leancloud_visitors" data-flag-title="LVS调度算法介绍">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="轮叫调度（Round-Robin）"><a href="#轮叫调度（Round-Robin）" class="headerlink" title="轮叫调度（Round Robin）"></a>轮叫调度（Round Robin）</h2><p>调度器通过“轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。大锅饭调度：rr - 纯轮询方式，比较垃圾。把每项请求按顺序在真正服务器中分派</p>
<h2 id="加权轮叫（Weighted-Round-Robin）"><a href="#加权轮叫（Weighted-Round-Robin）" class="headerlink" title="加权轮叫（Weighted Round Robin）"></a>加权轮叫（Weighted Round Robin）</h2><p>调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器能处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。<br>带权重的大锅饭调度：wrr -带权重轮询方式。把每项请求按顺序在真正服务器中循环分派，但是给能力较大的服务器分派较多的作业。</p>
<h2 id="最少链接（Least-Connections）"><a href="#最少链接（Least-Connections）" class="headerlink" title="最少链接（Least Connections）"></a>最少链接（Least Connections）</h2><p>调度器通过“最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用“最小连接”调度算法可以较好地均衡负载。<br>谁不干活就给谁分配：lc - 根据最小连接数分派</p>
<h2 id="加权最少链接（Weighted-Least-Connections）"><a href="#加权最少链接（Weighted-Least-Connections）" class="headerlink" title="加权最少链接（Weighted Least Connections）"></a>加权最少链接（Weighted Least Connections）</h2><p>在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。<br>带权重的谁不干活就给谁分配：wlc - 带权重的。机器配置好的权重高</p>
<h2 id="基于局部性的最少链接（Locality-Based-Least-Connections）"><a href="#基于局部性的最少链接（Locality-Based-Least-Connections）" class="headerlink" title="基于局部性的最少链接（Locality-Based Least Connections）"></a>基于局部性的最少链接（Locality-Based Least Connections）</h2><p>“基于局部性的最少链接”调度算法是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接” 的原则选出一个可用的服务器，将请求发送到该服务器。<br>基于地区的最少连接调度：lblc - 缓存服务器集群。基于本地的最小连接。把请求传递到负载小的服务器上</p>
<h2 id="带复制的基于局部性最少链接（Locality-Based-Least-Connections-with-Replication）"><a href="#带复制的基于局部性最少链接（Locality-Based-Least-Connections-with-Replication）" class="headerlink" title="带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）"></a>带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）</h2><p>“带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个目标 IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。<br>带有复制调度的基于地区的最少连接调度：lblcr - 带复制调度的缓存服务器集群。某页面缓存在服务器A上，被访问次数极高，而其他缓存服务器负载较低，监视是否访问同一页面，如果是访问同一页面则把请求分到其他服务器。</p>
<h2 id="目标地址散列（Destination-Hashing）"><a href="#目标地址散列（Destination-Hashing）" class="headerlink" title="目标地址散列（Destination Hashing）"></a>目标地址散列（Destination Hashing）</h2><p>“目标地址散列”调度算法根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。<br>目标散列调度：realserver中绑定两个ip。ld判断来者的ISP商，将其转到相应的IP。</p>
<h2 id="源地址散列（Source-Hashing）"><a href="#源地址散列（Source-Hashing）" class="headerlink" title="源地址散列（Source Hashing）"></a>源地址散列（Source Hashing）</h2><p>“源地址散列”调度算法根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。了解这些算法原理能够在特定的应用场合选择最适合的调度算法，从而尽可能地保持Real Server的最佳利用性。当然也可以自行开发算法，不过这已超出本文范围，请参考有关算法原理的资料。<br>源散列调度：源地址散列。基于client地址的来源区分。（用的很少）</p>
<h2 id="最短的期望的延迟（Shortest-Expected-Delay-Scheduling-SED）"><a href="#最短的期望的延迟（Shortest-Expected-Delay-Scheduling-SED）" class="headerlink" title="最短的期望的延迟（Shortest Expected Delay Scheduling SED）"></a>最短的期望的延迟（Shortest Expected Delay Scheduling SED）</h2><p>基于wlc算法。这个必须举例来说了ABC三台机器分别权重123 ，连接数也分别是123。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用sed算法后会进行这样一个运算A:（1+1)/1B:（1+2)/2C:（1+3)/3根据运算结果，把连接交给C 。</p>
<h2 id="最少队列调度（Never-Queue-Scheduling-NQ）"><a href="#最少队列调度（Never-Queue-Scheduling-NQ）" class="headerlink" title="最少队列调度（Never Queue Scheduling NQ）"></a>最少队列调度（Never Queue Scheduling NQ）</h2><p>无需队列。如果有台realserver的连接数＝0就直接分配过去，不需要在进行sed运算。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/27/Swagger-DOCS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/27/Swagger-DOCS/" itemprop="url">
                  Swagger DOCS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-27 20:37:26" itemprop="dateCreated datePublished" datetime="2016-09-27T20:37:26+08:00">2016-09-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Swagger/" itemprop="url" rel="index"><span itemprop="name">Swagger</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/27/Swagger-DOCS/" class="leancloud_visitors" data-flag-title="Swagger DOCS">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Swagger文档包含了一些有用的参考和简单的帮助信息，能够快速的使用Swagger 工具编辑你的API.</p>
<h2 id="Swagger-编辑器文档"><a href="#Swagger-编辑器文档" class="headerlink" title="Swagger 编辑器文档"></a>Swagger 编辑器文档</h2><p>Swagger Editor是一个开源的编辑器，基于Swagger规范来定义RESTful APIs文档信息，Swagger Editor源代码可以在GitHub上找到。</p>
<p>GitHub: <a href="https://github.com/swagger-api/swagger-editor" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-editor</a></p>
<h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><h4 id="在web浏览器上使用编辑器"><a href="#在web浏览器上使用编辑器" class="headerlink" title="在web浏览器上使用编辑器"></a>在web浏览器上使用编辑器</h4><p>这个编辑器可以在任意web浏览器上工作，可以在本机访问或者在从web服务器访问。</p>
<h4 id="本机上使用编辑器"><a href="#本机上使用编辑器" class="headerlink" title="本机上使用编辑器"></a>本机上使用编辑器</h4><p>你可以在你的机器上运行和使用Swagger Editor。</p>
<p><strong>先决条件</strong></p>
<p>在你下载并且运行Swagger Editor之前，你需要安装下面列出的依赖环境：</p>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a></li>
</ul>
<p>一旦NodeJS安装成功，通过npm的install命令安装所有的依赖。</p>
<p>npm install;</p>
<p><strong>使用http-server运行Editor</strong></p>
<p>Swagger Editor 可以在GibHub的共有仓库上找到。<br><a href="https://github.com/swagger-api/swagger-editor" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-editor</a></p>
<p>通过http-server模块来运行编辑器，从Github上面下载最后一个稳定版本，在你的终端上运行以下脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g http-server</span><br><span class="line">wget https://github.com/swagger-api/swagger-editor/releases/download/v2.10.4/swagger-editor.zip</span><br><span class="line">unzip swagger-editor.zip</span><br><span class="line">http-server swagger-editor</span><br></pre></td></tr></table></figure></p>
<p><strong>通过Docker运行编辑器</strong> </p>
<p>编辑器可以在Docker公共仓库找到。<br><a href="https://hub.docker.com/r/swaggerapi/swagger-editor/" target="_blank" rel="noopener">https://hub.docker.com/r/swaggerapi/swagger-editor/</a></p>
<p>通过以下脚本运行编辑器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull swaggerapi/swagger-editor</span><br><span class="line">docker run -p 80:8080 swaggerapi/swagger-editor</span><br></pre></td></tr></table></figure></p>
<h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p>Swagger 编辑器是一个基于Apache license的开源项目。你可以把你的建议，想法，bug共享到这个项目中，通过pull requests到<a href="https://github.com/swagger-api/swagger-editor" target="_blank" rel="noopener">Swagger Editor GitHub</a>。</p>
<p>按照以下流程在你的机器上运行编辑器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/swagger-api/swagger-editor.git</span><br><span class="line">cd swagger-editor</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li>如果npm start 不能够工作，就删除node_modules文件夹，然后运行npm install 和npm start</li>
<li>如果dist目录出现了问题，通过root权限去执行npm run build</li>
</ul>
<h2 id="Swagger-代码生成文档"><a href="#Swagger-代码生成文档" class="headerlink" title="Swagger 代码生成文档"></a>Swagger 代码生成文档</h2><p>Swagger代码生成工具是一个开源的工具，能够从一个Swagger定义的RESTful API来构建服务端和客户端的SDK文件。Swagger代码生成工具也可以在GitHub上面找到.</p>
<p>GitHub: <a href="https://github.com/swagger-api/swagger-codegen" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-codegen</a></p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><table>
<thead>
<tr>
<th>版本</th>
<th>发布时间</th>
<th style="text-align:center">规范兼容版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>2.3.0 (upcoming minor release)</td>
<td>TBD</td>
<td style="text-align:center">1.0, 1.1, 1.2, 2.0</td>
<td>Minor releases with breaking changes</td>
</tr>
<tr>
<td>2.2.2 (upcoming patch release)</td>
<td>TBD</td>
<td style="text-align:center">1.0, 1.1, 1.2, 2.0</td>
<td>Patch release (without breaking changes)</td>
</tr>
<tr>
<td>2.2.1 (current stable)</td>
<td>2016-08-07</td>
<td style="text-align:center">1.0, 1.1, 1.2, 2.0</td>
<td>tag v2.2.1</td>
</tr>
<tr>
<td>2.1.6</td>
<td>2016-04-06</td>
<td style="text-align:center">1.0, 1.1, 1.2, 2.0</td>
<td>tag v2.1.6</td>
</tr>
<tr>
<td>2.0.17</td>
<td>2014-08-22</td>
<td style="text-align:center">1.1, 1.2</td>
<td>tag v2.0.17</td>
</tr>
<tr>
<td>1.0.4</td>
<td>2012-04-12</td>
<td style="text-align:center">1.0, 1.1</td>
<td>tag v1.0.4</td>
</tr>
</tbody>
</table>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>先决条件</strong></p>
<p>在你机子下载运行Swagger代码生成工具之前需要安装以下的依赖环境：</p>
<ul>
<li>Java, version 7 or higher</li>
</ul>
<p><strong>Installation with Homebrew</strong></p>
<p>如果你是mac或者linux环境，你可以通过Homebrew来安装Swagger Codegen。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install swagger-codegen</span><br></pre></td></tr></table></figure></p>
<p><strong>Installation from Maven Central</strong></p>
<p>所有的Swagger Codegen版本都可以在<a href="https://oss.sonatype.org/content/repositories/releases/io/swagger/" target="_blank" rel="noopener">Maven Central</a>找到，并且你可以选择适合的版本（我们推荐最后一个版本）.</p>
<p>你可以下载并运行这个executable .jar文件(比如：swagger-codegen-cli-2.2.1.jar)</p>
<p>或者你可以使用wget命令下载：<br>wget {link address of the executable .jar file}</p>
<p>例如：<br>wget <a href="https://oss.sonatype.org/content/repositories/releases/io/swagger/swagger-codegen-cli/2.2.1/swagger-codegen-cli-2.2.1.jar" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/releases/io/swagger/swagger-codegen-cli/2.2.1/swagger-codegen-cli-2.2.1.jar</a></p>
<p><strong>用法</strong></p>
<p>假设我们已经安装好了swagger-codegen-cli-2.2.1，你可以访问wagger Codegen 安装章节来学习怎么在你的机器上安装。</p>
<p><strong>List of supported languages</strong></p>
<p>To get a list of languages supported by the Swagger Codegen -<br>Swagger Codegen可以获取多种语言的列表信息。<br>如果你安装了Homebrew，执行以下命令：<br>swagger-codegen<br>或者你也可以使用以下命令:<br>java -jar swagger-codegen-cli-2.2.1.jar</p>
<p><strong>Help options in terminal</strong></p>
<p>执行以下命令可以获取帮助信息。<br>如果你安装了Homebrew，执行以下命令：<br>swagger-codegen help<br>或者你也可以使用以下命令:<br>java -jar swagger-codegen-cli-2.2.1.jar help</p>
<p>你也可以了解具体的某个命令的用法：<br>如果你安装了Homebrew，执行以下命令：<br>swagger-codegen help <command><br>Example:<br>swagger-codegen help generate<br>或者你也可以使用以下命令:<br>java -jar swagger-codegen-cli-2.2.1.jar help<br>Example:<br>java -jar swagger-codegen-cli-2.2.1.jar help generate</p>
<p>你也可以了解某个语言的帮助信息：<br>If you have Homebrew installed:<br>swagger-codegen config-help -l <language name=""><br>Example:<br>swagger-codegen config-help -l php<br>Else, you could use:<br>java -jar swagger-codegen-cli-2.2.1.jar config-help -l <language name=""><br>Example:<br>java -jar swagger-codegen-cli-2.2.1.jar config-help -l php</language></language></p>
<p>Once you have the various help section options, you can learn about a specific topic.<br>If you have Homebrew installed:<br>swagger-codegen help <command><br>Example:<br>swagger-codegen help generate<br>Else, you could use:<br>java -jar swagger-codegen-cli-2.2.1.jar help<br>Example:<br>java -jar swagger-codegen-cli-2.2.1.jar help generate</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>从一个已经编写好的swagger 规范中生成代码.<br>If you have Homebrew installed:</p>
<p>swagger-codegen generate -i <path of="" your="" swagger="" specification=""></path> -l <language></language></p>
<p>Example:</p>
<p>swagger-codegen generate -i <a href="http://petstore.swagger.io/v2/swagger.json" target="_blank" rel="noopener">http://petstore.swagger.io/v2/swagger.json</a> -l csharp</p>
<p>Else, you could use:</p>
<p>java -jar swagger-codegen-cli-2.2.1.jar -i <path of="" your="" swagger="" specification=""></path> -l <language> ` Example:</language></p>
<p>swagger-codegen generate -i <a href="http://petstore.swagger.io/v2/swagger.json" target="_blank" rel="noopener">http://petstore.swagger.io/v2/swagger.json</a> -l csharp</p>
<p>在上面的代码中，我们通过2个参数：-i和-l来执行.-i指向了你的api规范文件路径。-l代表了你想要生成某个语言的代码。</p>
<p>生成工具有一个README文件，包含了所有的运行和构建api的信息。通过了解它来构建你的API.</p>
<h3 id="贡献-1"><a href="#贡献-1" class="headerlink" title="贡献"></a>贡献</h3><p>Swagger生成工具也是基于Apache协议的开源项目，如果你有什么建议，想法，bug都可以提交到GitHub repository，地址：<br><a href="https://github.com/swagger-api/swagger-codegen" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-codegen</a>.</p>
<h4 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h4><p><strong>Before submitting an issue</strong>    </p>
<ul>
<li>If you’re not using the latest master to generate API clients or server stubs, please give it another try by pulling the latest master as the issue may have already been addressed. Ref: Getting Started</li>
<li>Search the open issue and closed issue to ensure no one else has reported something similar before.</li>
<li>File an issue ticket by providing all the required information.</li>
<li>Test with the latest master by building the JAR locally to see if the issue has already been addressed.</li>
<li><p>You can also make a suggestion or ask a question by opening an “issue”.</p>
<p><strong>Before submitting a PR</strong></p>
</li>
<li><p>Search the open issue to ensure no one else has reported something similar and no one is actively working on similar proposed change.</p>
</li>
<li>If no one has suggested something similar, open an “issue” with your suggestion to gather feedback from the community.</li>
<li>It’s recommended to create a new git branch for the change so that the merge commit message looks nicer in the commit history.</li>
</ul>
<p><strong>How to contribute</strong></p>
<p>Code generators</p>
<p>All the code generators can be found in modules/swagger-codegen/src/main/java/io/swagger/codegen/languages</p>
<p>Templates</p>
<p>All the templates (mustache) can be found in modules/swagger-codegen/src/main/resources.</p>
<p>For a list of variables available in the template, please refer to this page</p>
<p><strong>Style guide</strong></p>
<p>Code change should conform to the programming style guide of the respective langauages:</p>
<ul>
<li>Android: <a href="https://source.android.com/source/code-style.html" target="_blank" rel="noopener">https://source.android.com/source/code-style.html</a></li>
<li>C#: <a href="https://msdn.microsoft.com/en-us/library/vstudio/ff926074.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/vstudio/ff926074.aspx</a></li>
<li>C++: <a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">https://google.github.io/styleguide/cppguide.html</a></li>
<li>Haskell: <a href="https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md" target="_blank" rel="noopener">https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md</a></li>
<li>Java: <a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener">https://google.github.io/styleguide/javaguide.html</a></li>
<li>JavaScript: <a href="https://github.com/airbnb/javascript/tree/master/es5" target="_blank" rel="noopener">https://github.com/airbnb/javascript/tree/master/es5</a></li>
<li>Groovy: <a href="http://groovy-lang.org/style-guide.html" target="_blank" rel="noopener">http://groovy-lang.org/style-guide.html</a></li>
<li>Go: <a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></li>
<li>ObjC: <a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="noopener">https://github.com/NYTimes/objective-c-style-guide</a></li>
<li>Perl: <a href="http://perldoc.perl.org/perlstyle.html" target="_blank" rel="noopener">http://perldoc.perl.org/perlstyle.html</a></li>
<li>PHP: <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md" target="_blank" rel="noopener">https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md</a></li>
<li>Python: <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></li>
<li>Ruby: <a href="https://github.com/bbatsov/ruby-style-guide" target="_blank" rel="noopener">https://github.com/bbatsov/ruby-style-guide</a></li>
<li>Scala: <a href="http://docs.scala-lang.org/style/" target="_blank" rel="noopener">http://docs.scala-lang.org/style/</a></li>
<li>Swift: <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html" target="_blank" rel="noopener">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html</a></li>
<li>TypeScript: <a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines</a></li>
</ul>
<p>For other languages, feel free to suggest.</p>
<p>You may find the current code base not 100% conform to the coding style and we welcome contributions to fix those.</p>
<p>For Vendor Extensions, please follow the naming convention below:</p>
<ul>
<li>For general vendor extension, use lower case and hyphen. e.g. x-is-unique, x-content-type</li>
<li>For language-specified vendor extension, put it in the form of x-{lang}-{extension-name}. e.g. x-objc-operation-id, x-java-feign-retry-limit</li>
<li>For a list of existing vendor extensions in use, please refer to <a href="https://github.com/swagger-api/swagger-codegen/wiki/Vendor-Extensions" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-codegen/wiki/Vendor-Extensions</a>. If you’ve addaed new vendor extensions as part of your PR, please update the wiki page.</li>
</ul>
<p><strong>Testing</strong></p>
<p>To add test cases (optional) covering the change in the code generator, please refer to modules/swagger-codegen/src/test/java/io/swagger/codegen</p>
<p>To test the templates, please perform the following:</p>
<ul>
<li>Update the Petstore sample by running the shell script under bin folder. For example, run ./bin/ruby-petstore.sh to update the Ruby PetStore API client under samples/client/petstore/ruby For Windows, the batch files can be found under bin\windows folder. (If you find that there are new files generated or unexpected changes as a result of the update, that’s not unusual as the test cases are added to the OpenAPI/Swagger spec from time to time. If you’ve questions or concerns, please open a ticket to start a discussion)</li>
<li>Run the tests in the sample folder, e.g. in samples/client/petstore/ruby, run mvn integration-test -rf :RubyPetstoreClientTests. (some languages may not contain unit testing for Petstore and we’re looking for contribution from the community to implement those tests)</li>
<li>Finally, git commit the updated samples files: git commit -a (git add -A if added files with new test cases)</li>
</ul>
<p>To start the CI tests, you can run mvn verify -Psamples (assuming you’ve all the required tools installed to run tests for different languages) or you can leverage <a href="http://travis-ci.org" target="_blank" rel="noopener">http://travis-ci.org</a> to run the CI tests by adding your own Swagger-Codegen repository.</p>
<p>Tips</p>
<ul>
<li>Smaller changes are easier to review</li>
<li>[Optional] For bug fixes, provide a OpenAPI Spec to repeat the issue so that the reviewer can use it to confirm the fix</li>
<li>Add test case(s) to cover the change</li>
<li>Document the fix in the code to make the code more readable</li>
<li>Make sure test cases passed after the change (one way is to leverage <a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a> to run the CI tests)</li>
<li>File a PR with meaningful title, description and commit messages. A good example is PR-3306</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/26/Swagger-Editor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/26/Swagger-Editor/" itemprop="url">
                  Swagger Editor
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-26 21:37:26" itemprop="dateCreated datePublished" datetime="2016-09-26T21:37:26+08:00">2016-09-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Swagger/" itemprop="url" rel="index"><span itemprop="name">Swagger</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/26/Swagger-Editor/" class="leancloud_visitors" data-flag-title="Swagger Editor">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Swagger Editor 能够让你在YAML文件里编辑Swagger API规格说明书，并且能够在你的浏览器实时的预览文档内容。能够使用Swagger工具自动生成一些有效的JSON文档描述，还可以生成代码。</p>
<p><a href="http://editor.swagger.io/" target="_blank" rel="noopener">在线例子</a></p>
<p><img src="https://raw.githubusercontent.com/swagger-api/swagger-editor/2.x/docs/screenshot.png" alt="Screenshot of the Swagger Editor"></p>
<h2 id="Docker环境运行"><a href="#Docker环境运行" class="headerlink" title="Docker环境运行"></a>Docker环境运行</h2><p>这个 swagger-editor 已经在Dockerhub上的公有仓库中<a href="https://hub.docker.com/r/swaggerapi/swagger-editor/" target="_blank" rel="noopener">发布</a>了。<br>你可以很容易的在docker中运行editor：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull swaggerapi/swagger-editor</span><br><span class="line">docker run -p 80:8080 swaggerapi/swagger-editor</span><br></pre></td></tr></table></figure></p>
<h2 id="本机环境运行"><a href="#本机环境运行" class="headerlink" title="本机环境运行"></a>本机环境运行</h2><p><a href="https://github.com/swagger-api/swagger-editor/releases/download/v2.10.4/swagger-editor.zip" target="_blank" rel="noopener">下载</a>最后一个稳定版本(v2.10.4)并且可以通过访问你的HTTP server访问静态静态文件内容 .如果你没有HTTP server,你可以使用Node.js 提供的http-server模块。</p>
<p>使用http-server模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g http-server</span><br><span class="line">wget https://github.com/swagger-api/swagger-editor/releases/download/v2.10.4/swagger-editor.zip</span><br><span class="line">unzip swagger-editor.zip</span><br><span class="line">http-server swagger-editor</span><br></pre></td></tr></table></figure></p>
<h2 id="构建源码"><a href="#构建源码" class="headerlink" title="构建源码"></a>构建源码</h2><p>确保你的电脑安装了<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/swagger-api/swagger-editor.git</span><br><span class="line">cd swagger-editor</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="https://github.com/swagger-api/swagger-editor/blob/master/docs/import.md" target="_blank" rel="noopener">导入你的Swagger文档</a></li>
<li><a href="https://github.com/swagger-api/swagger-editor/blob/master/docs/development.md" target="_blank" rel="noopener">开发者指南</a></li>
<li><a href="https://github.com/swagger-api/swagger-editor/blob/master/docs/config.md" target="_blank" rel="noopener">配置指南</a></li>
<li><a href="https://github.com/swagger-api/swagger-editor/blob/master/docs/cors.md" target="_blank" rel="noopener">跨域请求问题</a></li>
</ul>
<p><a href="https://github.com/swagger-api/swagger-editor/blob/master/.github/CONTRIBUTING.md" target="_blank" rel="noopener">贡献</a></p>
<p><a href="https://github.com/swagger-api/swagger-editor/blob/master/LICENSE" target="_blank" rel="noopener">LICENSE</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/25/Spring-Cloud-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/25/Spring-Cloud-Introduction/" itemprop="url">
                  Spring Cloud 介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-25 19:58:47" itemprop="dateCreated datePublished" datetime="2016-09-25T19:58:47+08:00">2016-09-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/25/Spring-Cloud-Introduction/" class="leancloud_visitors" data-flag-title="Spring Cloud 介绍">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spring Cloud作为开发者在分布式环境里快速构建某些常见模式的云应用工具。（比如：配置管理，服务发现，断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理）。使用Spring Cloud开发环境能够快速的启动服务并实现。<br>它们在任何的分布式环境中能够很好的工作，包括开发者的笔记本，数据中心，还有管理平台比如Cloud Foundry。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>Spring Cloud 构建在Spring Boot基础上的一个库，添加到你的应用程序上下文中，你可以使用它的默认配置来快速的开始，当你需要的时候，你也可以配置或者扩展来创建一个自己的解决方案。</p>
<p>推荐在你的项目里使用依赖管理去使用spring-cloud，你可以粘贴到你的构建环境中，如果需要帮助，可以看我们提供的开始指南章节（怎么使用<a href="http://spring.io/guides/gs/maven/" target="_blank" rel="noopener">Maven</a>和<a href="http://spring.io/guides/gs/gradle/" target="_blank" rel="noopener">Gradle</a>进行构建）。<br>下面是maven的配置信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;Brixton.SR6&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>
<p>你也可以使用gradle风格：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">	ext &#123;</span><br><span class="line">		springBootVersion = <span class="string">'1.3.7.RELEASE'</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">repositories</span> &#123;</span><br><span class="line">		mavenCentral()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">dependencies</span> &#123;</span><br><span class="line">		<span class="keyword">classpath</span>(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>) </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line">apply plugin: <span class="string">'spring-boot'</span> </span><br><span class="line"></span><br><span class="line">dependencyManagement &#123;</span><br><span class="line">  imports &#123;</span><br><span class="line">    mavenBom <span class="string">'org.springframework.cloud:spring-cloud-dependencies:Brixton.SR6'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'org.springframework.cloud:spring-cloud-starter-eureka'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>分布式/版本控制 配置管理</li>
<li>服务注册和发现</li>
<li>路由</li>
<li>服务之间的调用</li>
<li>负载均衡</li>
<li>断路器</li>
<li>全局锁</li>
<li>选举和集群状态管理</li>
<li>分布式消息</li>
</ol>
<p>Spring Cloud 提供了一些注解声明，通过注解可以获得很多特性。比如下面的例子是一个发现客户端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="主要的项目"><a href="#主要的项目" class="headerlink" title="主要的项目"></a>主要的项目</h2><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。这些配置信息会映射到Spring 环境中，你也可以使用非Spring应用程序。</p>
<h3 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h3><p>各种组件的集成(比如：Eureka(服务发现), Hystrix(熔断器), Zuul(提供动态路由，监控，弹性，安全等边缘服务的框架), Archaius(配置管理)，Ribbon（提供云端负载均衡），Turbine（聚合服务器发送事件流数据的一个工具，用来监控集群下hystrix的metrics情况）)。</p>
<h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</p>
<h3 id="Spring-Cloud-for-Cloud-Foundry"><a href="#Spring-Cloud-for-Cloud-Foundry" class="headerlink" title="Spring Cloud for Cloud Foundry"></a>Spring Cloud for Cloud Foundry</h3><p>通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。</p>
<h3 id="Spring-Cloud-Cloud-Foundry-Service-Broker"><a href="#Spring-Cloud-Cloud-Foundry-Service-Broker" class="headerlink" title="Spring Cloud Cloud Foundry Service Broker"></a>Spring Cloud Cloud Foundry Service Broker</h3><p>作为一个云管理平台服务的切入点。</p>
<h3 id="Spring-Cloud-Cluster"><a href="#Spring-Cloud-Cluster" class="headerlink" title="Spring Cloud Cluster"></a>Spring Cloud Cluster</h3><p>提供Leadership选举，如：Zookeeper, Redis, Hazelcast, Consul等常见状态模式的抽象和实现。</p>
<h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><p>封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p>
<h3 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h3><p>基于spring security的安全工具包，为你的应用程序添加安全控制。</p>
<h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p>
<h3 id="Spring-Cloud-Data-Flow"><a href="#Spring-Cloud-Data-Flow" class="headerlink" title="Spring Cloud Data Flow"></a>Spring Cloud Data Flow</h3><p>大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</p>
<h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><p>数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</p>
<h3 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h3><p>提供云端计划任务管理、任务调度。</p>
<h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h3><p>操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理。</p>
<h3 id="Spring-Cloud-for-Amazon-Web-Services"><a href="#Spring-Cloud-for-Amazon-Web-Services" class="headerlink" title="Spring Cloud for Amazon Web Services"></a>Spring Cloud for Amazon Web Services</h3><p>和亚马逊服务的集成。</p>
<h3 id="Spring-Cloud-Connectors"><a href="#Spring-Cloud-Connectors" class="headerlink" title="Spring Cloud Connectors"></a>Spring Cloud Connectors</h3><p>便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。</p>
<h3 id="Spring-Cloud-Starters"><a href="#Spring-Cloud-Starters" class="headerlink" title="Spring Cloud Starters"></a>Spring Cloud Starters</h3><p>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。</p>
<h3 id="Spring-Cloud-CLI"><a href="#Spring-Cloud-CLI" class="headerlink" title="Spring Cloud CLI"></a>Spring Cloud CLI</h3><p>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="陈均" />
            
              <p class="site-author-name" itemprop="name">陈均</p>
              <p class="site-description motion-element" itemprop="description">世间万物皆空。唯其空，便能包容万物。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈均</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>



  <div class="footer-custom"><a target="_blank" rel="external nofollow" href="http://beian.miit.gov.cn"><b>蜀ICP备17001803号</b></a></div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("X2YtjBbKwWtfKz2jH6SBGpLa-gzGzoHsz", "S6zjXgoW7l4HGNvpcJrXroPJ");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! See more at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see here how to solve it: https://github.com/theme-next/hexo-leancloud-counter-security. \n But you also can use LeanCloud without security, by set \'security\' option to \'false\'.');
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
