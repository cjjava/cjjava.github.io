<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="世间万物皆空。唯其空，便能包容万物。">
<meta property="og:type" content="website">
<meta property="og:title" content="永恒之道">
<meta property="og:url" content="http://cjoop.top/page/2/index.html">
<meta property="og:site_name" content="永恒之道">
<meta property="og:description" content="世间万物皆空。唯其空，便能包容万物。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="永恒之道">
<meta name="twitter:description" content="世间万物皆空。唯其空，便能包容万物。">






  <link rel="canonical" href="http://cjoop.top/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>永恒之道</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">永恒之道</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/25/RabbitMQ-Install-on-RPM-based-Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/25/RabbitMQ-Install-on-RPM-based-Linux/" itemprop="url">
                  RabbitMQ Install on RPM-based Linux
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-25 19:18:33" itemprop="dateCreated datePublished" datetime="2016-09-25T19:18:33+08:00">2016-09-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/25/RabbitMQ-Install-on-RPM-based-Linux/" class="leancloud_visitors" data-flag-title="RabbitMQ Install on RPM-based Linux">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务下载"><a href="#服务下载" class="headerlink" title="服务下载"></a>服务下载</h2><table>
<thead>
<tr>
<th>Description</th>
<th>Download</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPM for Fedora / RHEL / CentOS Linux (from rabbitmq.com)</td>
<td><a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm" target="_blank" rel="noopener">rabbitmq-server-3.6.5-1.noarch.rpm</a></td>
</tr>
<tr>
<td>RPM for openSUSE Linux (from rabbitmq.com)</td>
<td><a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.suse.noarch.rpm" target="_blank" rel="noopener">rabbitmq-server-3.6.5-1.suse.noarch.rpm</a></td>
</tr>
<tr>
<td>RPM for Fedora / RHEL / CentOS Linux (from github.com)</td>
<td><a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/rabbitmq_v3_6_5/rabbitmq-server-3.6.5-1.noarch.rpm" target="_blank" rel="noopener">rabbitmq-server-3.6.5-1.noarch.rpm</a></td>
</tr>
</tbody>
</table>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>rabbitmq-server已经包含在Fedora系统中，但是，这个版本往往比较旧。通过我们的站点安装.rpm格式的文件会获得更好的结果。检查Fedora 包详情获得服务器版本信息。</p>
<h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><p>在安装RabbitMQ之前，你必须安装Erlang环境。我们建议使用一个打包版本。这里有三种来源方式：</p>
<ul>
<li><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener">Erlang 方案</a> 通常是最新的安装包,提供两种方式，一种通过yum 仓库进行安装，另一种通过手动下载安装。</li>
<li>我们提供了一个适合运行RabbitMQ服务的<a href="https://github.com/rabbitmq/erlang-rpm" target="_blank" rel="noopener">依赖包</a>,这个包不是最新的，但是能够很好的解决依赖问题。</li>
<li><a href="http://fedoraproject.org/wiki/EPEL" target="_blank" rel="noopener">EPEL</a> (“Extra Packages for Enterprise Linux”); 有一部分的 Red Hat / Fedora 机构,提供了一些额外的包,包含了 Erlang. 他们都是正式的安装包，并被分成了很多个小包，但不是最新的。</li>
</ul>
<h3 id="从Erlang官网的仓库进行安装"><a href="#从Erlang官网的仓库进行安装" class="headerlink" title="从Erlang官网的仓库进行安装"></a>从Erlang官网的仓库进行安装</h3><ol>
<li>可以通过使用仓库来安装Erlang。</li>
</ol>
<h3 id="或者下载单独的包进行安装"><a href="#或者下载单独的包进行安装" class="headerlink" title="或者下载单独的包进行安装"></a>或者下载单独的包进行安装</h3><ol>
<li>下载安装 <a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener">esl-erlang RPM</a>进行安装。</li>
<li>下载安装 <a href="https://github.com/jasonmcintosh/esl-erlang-compat/releases/download/1.1.1/esl-erlang-compat-18.1-1.noarch.rpm" target="_blank" rel="noopener">esl-erlang-compat RPM</a>兼容包。</li>
</ol>
<h3 id="或者从RabbitMQ安装零依赖的Erlang"><a href="#或者从RabbitMQ安装零依赖的Erlang" class="headerlink" title="或者从RabbitMQ安装零依赖的Erlang"></a>或者从RabbitMQ安装零依赖的Erlang</h3><ol>
<li>下载安装零依赖的<a href="https://github.com/rabbitmq/erlang-rpm" target="_blank" rel="noopener">Erlang RPM</a> 包.</li>
</ol>
<h3 id="或者从EPEL仓库安装Erlang"><a href="#或者从EPEL仓库安装Erlang" class="headerlink" title="或者从EPEL仓库安装Erlang"></a>或者从EPEL仓库安装Erlang</h3><ol>
<li>在你的机器上激活EPEL。</li>
<li>通过root账户执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install erlang</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="安装RabbitMQ服务"><a href="#安装RabbitMQ服务" class="headerlink" title="安装RabbitMQ服务"></a>安装RabbitMQ服务</h2><p>下载rpm文件，通过root账户执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc</span><br><span class="line">yum install rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>我们的公钥信息也可以从这里<a href="https://bintray.com/user/downloadSubjectPublicKey?username=rabbitmq" target="_blank" rel="noopener">下载</a>.</p>
<h3 id="Using-PackageCloud-RPM-Repository"><a href="#Using-PackageCloud-RPM-Repository" class="headerlink" title="Using PackageCloud RPM Repository"></a>Using PackageCloud RPM Repository</h3><p>PackageCloud installs packages via HTTPS and signs them using their GPG key. There are multiple ways to install:</p>
<p>Provided installation scripts<br>Using PackageCloud Chef cookbook<br>Using PackageCloud Puppet module<br>Manually<br>See <a href="https://packagecloud.io/rabbitmq/rabbitmq-server/install" target="_blank" rel="noopener">PackageCloud RabbitMQ repository instructions</a>.</p>
<h2 id="运行RabbitMQ服务"><a href="#运行RabbitMQ服务" class="headerlink" title="运行RabbitMQ服务"></a>运行RabbitMQ服务</h2><p>自定义RabbitMQ环境变量<br>　　服务启动采用的是默认配置，你可以自定义RabbitMQ环境变量，这里告诉你这样<a href="http://www.rabbitmq.com/configure.html#configuration-file" target="_blank" rel="noopener">配置组件</a>。<br>启动服务<br>　　The server is not started as a daemon by default when the RabbitMQ server package is installed. To start the daemon by default when the system boots, as an administrator run chkconfig rabbitmq-server on.这个服务在安装以后不会以守护进程运行。默认情况下守护进程会随着系统启动而运行，通过管理员账号运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure></p>
<p>通过管理员账号可以启动和停止该服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/service rabbitmq-server stop/start/etc.</span><br></pre></td></tr></table></figure></p>
<p>备注：这个服务作为系统用户运行，如果你改变了Mnesia数据库或者日志<br>，你必须确保这些文件是该用户的。</p>
<h2 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h2><p>SELinux and similar 机器也许会阻止RabbitMQ绑定端口。这种情况下，RabbitMQ将会启动失败。确保以下端口是被允许打开的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4369 (epmd), 25672 (Erlang distribution)</span><br><span class="line">5672, 5671 (AMQP 0-9-1 without and with TLS)</span><br><span class="line">15672 (<span class="keyword">if</span> management plugin is enabled)</span><br><span class="line">61613, 61614 (<span class="keyword">if</span> STOMP is enabled)</span><br><span class="line">1883, 8883 (<span class="keyword">if</span> MQTT is enabled)</span><br></pre></td></tr></table></figure></p>
<p>可以配置<a href="http://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">RabbitMQ</a>使用其他端口。</p>
<h2 id="默认用户访问"><a href="#默认用户访问" class="headerlink" title="默认用户访问"></a>默认用户访问</h2><p>这个服务创建了一个用户名guest密码为guest的用户。没有配置的客户端将采用这个用户。默认情况下这个凭证只能用于连接本机。</p>
<p>查看文档中访问控制信息。了解如何创建更多的用户、删除guest用户，或者允许guest用户进行远程访问。</p>
<h2 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h2><p>怎么停止服务或者检查它的状态等，你可以调用sbin/rabbitmqctl(作为运行rabbitmq-server的用户来操作)。如果没有服务在运行rabbitmqctl命令将报告节点不在线的信息。</p>
<ul>
<li>调用 rabbitmqctl stop 命令停止服务.</li>
<li>调用 rabbitmqctl status 检查服务运行状态.</li>
</ul>
<p>更多的信息查看<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html" target="_blank" rel="noopener">rabbitmqctl</a></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>服务输出的信息会发送到RABBITMQ_NODENAME.log文件中并保存在RABBITMQ_LOG_BASE 目录。附加的日志信息会写到RABBITMQ_NODENAME-sasl.log文件中。</p>
<h2 id="控制系统的限制"><a href="#控制系统的限制" class="headerlink" title="控制系统的限制"></a>控制系统的限制</h2><p>RabbitMQ安装运行在生产环境的工作负载情况下需要对系统的内核参数限制进行调整，保证一个合适的数量来处理并发的连接和队列。这里主要设置打开文件的最大数量，可以使用这个命令 ulimit -n。许多操作系统作为一个消息代理来说这个默认值太低了（大部分的linux默认值都是1024）。我们推荐使用最少65536的文件描述符作为用户rabbitmq的生产环境，4096 基本上满足大多数开发工作负载。</p>
<p>这里有2个限制参数：最大允许打开的文件数(fs.file-max on Linux, kern.maxfilesperproc on OS X and FreeBSD)和per-user 限制数(ulimit -n)。前者必须高于后者。</p>
<p>在分布式系统里面，通过配置/etc/systemd/system/rabbitmq-server.service.d/limits.conf文件来控制，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">LimitNOFILE=300000</span><br></pre></td></tr></table></figure></p>
<p>还有种最简单的方法来限制每个用户，就是在启动服务之前调用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -S -n 4096</span><br></pre></td></tr></table></figure></p>
<p>这个软限制不能够操作硬限制(许多分布式环境中默认为4096)。这个硬限制也可以在/etc/security/limits.conf中修改。必须要激活pam_limits.so模块并重新登陆或者重启系统。</p>
<p>Note that limits cannot be changed for running OS processes.</p>
<p>For more information about controlling fs.file-max with sysctl, please refer to the excellent Riak guide on open file limit tuning.</p>
<h2 id="验证限制"><a href="#验证限制" class="headerlink" title="验证限制"></a>验证限制</h2><p><a href="http://www.rabbitmq.com/management.html" target="_blank" rel="noopener">UI管理页面</a> 在概述这个选项卡里显示了可用的文件描述符数量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure></p>
<p>上面的信息也包含了同样的值。<br>下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/$RABBITMQ_BEAM_PROCESS_PID/limits</span><br></pre></td></tr></table></figure></p>
<p>用于显示运行进程的有效限制数。$RABBITMQ_BEAM_PROCESS_PID 是系统的PID，作为在Erlang VM运行的RabbitMQ。通过rabbitmqctl status返回。</p>
<p>##配置管理工具<br>配置管理工具(比如：Chef, Puppet, BOSH)提供了对系统限制的调整。我们的<a href="http://www.rabbitmq.com/devtools.html#devops-tools" target="_blank" rel="noopener">开发工具</a>指南里面列出了相关的模块和项目。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/24/RabbitMQ-Clustering-Guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/24/RabbitMQ-Clustering-Guide/" itemprop="url">
                  RabbitMQ Clustering Guide
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-24 22:37:26" itemprop="dateCreated datePublished" datetime="2016-09-24T22:37:26+08:00">2016-09-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/24/RabbitMQ-Clustering-Guide/" class="leancloud_visitors" data-flag-title="RabbitMQ Clustering Guide">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个RabbitMQ服务作为一个逻辑组或者几个Erlang节点，所有运行的Rabbitmq应用程序共享用户信息，虚拟主机，队列，交换器，绑定信息，运行参数。我们把引用的节点集合作为一个集群。</p>
<h2 id="什么是复制"><a href="#什么是复制" class="headerlink" title="什么是复制?"></a>什么是复制?</h2><p>对于在RabbitMQ服务中操作的所有数据和状态信息在所有的节点中都被复制，具有可靠性和伸缩性，满足ACID要求。但是存在一个例外是针对 message queue的，其默认是仅存在于创建它的那个 node 上面，尽管其同时对于所有其他 node 是可见和可达的。为了在 cluster 中的所有 node 上复制某个 queue 的内容，参考 <a href="https://www.rabbitmq.com/ha.html" target="_blank" rel="noopener">high availability</a> 相关文档（首先你可能需要一个可用的集群环境） 。</p>
<h2 id="主机名解析要求"><a href="#主机名解析要求" class="headerlink" title="主机名解析要求"></a>主机名解析要求</h2><p>RabbitMQ的节点地址信息使用的是域名，短的或者完整的有效域名。因此集群中的所有成员都必须能够解析来自集群中节点的主机名信息，这样才能够在任何一台机子上使用命令行工具rabbitmqctl。</p>
<p>主机名解析可以使用任何一种标准的方式：</p>
<ol>
<li>DNS records</li>
<li>Local host files (e.g. /etc/hosts)</li>
</ol>
<p>In more restrictive environments, where DNS record or hosts file modification is restricted, impossible or undesired, Erlang VM can be configured to use alternative hostname resolution methods, such as an alternative DNS server, a local file, a non-standard hosts file location, or a mix of methods. Those methods can work in concert with the standard OS hostname resolution methods.</p>
<p>使用FQDN的话，在<a href="http://www.rabbitmq.com/configure.html#define-environment-variables" target="_blank" rel="noopener">配置指南</a>中查看RABBITMQ_USE_LONGNAME属性。</p>
<h2 id="集群构成"><a href="#集群构成" class="headerlink" title="集群构成"></a>集群构成</h2><p>集群可以通过以下的任何一种方式进行构成：</p>
<ol>
<li>通过rabbitmqctl手动操作(比如在开发环境中)</li>
<li>在<a href="http://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">配置文件</a>中声明集群节点列表</li>
<li>使用<a href="https://github.com/aweber/rabbitmq-autocluster/" target="_blank" rel="noopener">rabbitmq-autocluster</a>方式 (一个插件)</li>
</ol>
<p>集群的组成可以动态的改变。所有 RabbitMQ broker 在最初启动时都是从单独的一个节点开始的。 这些 node 可以加入到同一个 cluster 中，之后还可以重新退回成单个节点运行。</p>
<h2 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h2><p>RabbitMQ服务允许容忍单个节点的失效。节点可以随时启动和停止，只要他们可以在停止的时候通知一个已知的群集成员节点。</p>
<p> RabbitMQ有几种方式去处理网络分区问题，主要面向一致性。集群环境主要被使用在LAN(局域网)环境。不建议在WAN(广域网)环境下运行集群环境。通过使用<a href="https://www.rabbitmq.com/shovel.html" target="_blank" rel="noopener">Shovel</a>或者<a href="https://www.rabbitmq.com/federation.html" target="_blank" rel="noopener">Federation</a>插件可以很好的在WAN环境中连接服务。Note that <a href="https://www.rabbitmq.com/distributed.html" target="_blank" rel="noopener">Shovel and Federation are not equivalent to clustering</a>.</p>
<h2 id="磁盘和内存节点"><a href="#磁盘和内存节点" class="headerlink" title="磁盘和内存节点"></a>磁盘和内存节点</h2><p>一个节点可以是一个磁盘节点或者一个内存节点。（备注：磁盘之间可以进行相互转换）。在大多数情况下你希望你的所有节点都是磁盘节点；内存节点是在特殊情况下为了提升集群中队列，交换器，绑定等性能使用的，如果你有疑问的话，可以只使用磁盘节点。</p>
<h2 id="集群操作示范"><a href="#集群操作示范" class="headerlink" title="集群操作示范"></a>集群操作示范</h2><p>下面是一份建立和操控 RabbitMQ cluster 的示范。其中包括 3 台机器 - rabbit1，rabbit2，rabbit3.</p>
<p>我们假设用户能够登陆到这三台机器上，RabbitMQ也已经安装在机器上了，并且rabbitmq-server和rabbitmqctl脚本命令在用户的PATH环境变量中配置好了。</p>
<p>这个示例可以被修改来在单个主机上运行，详细的细节在后面说明。</p>
<h2 id="节点-和CLI工具-怎么认证其他节点-使用ErlangCookie方式"><a href="#节点-和CLI工具-怎么认证其他节点-使用ErlangCookie方式" class="headerlink" title="节点(和CLI工具)怎么认证其他节点: 使用ErlangCookie方式"></a>节点(和CLI工具)怎么认证其他节点: 使用ErlangCookie方式</h2><p>RabbitMQ节点和CLI工具(比如：rabbitmqctl)使用cookie值来确定 node 间是否允许相互通信，两个 node 能够相互通信的前提是他们必须拥有相同的 Erlang cookie值。 这个cookie是一个字母数字组成的字符串。它的长度可以是长的或者短的。<br>每个集群节点必须具有相同的cookie。</p>
<p>在RabbitMQ服务启动的时候Erlang虚拟机会自动的创建一个随机的cookie文件。并且把它复制到集群环境里的所有其他节点中。</p>
<p>在Unix系统中,这个cookie文件通常位于 /var/lib/rabbitmq/.erlang.cookie 或者 $HOME/.erlang.cookie.</p>
<p>在Windows系统中,这个文件路径在 C:\Users\Current User.erlang.cookie (%HOMEDRIVE% + %HOMEPATH%.erlang.cookie) 或者 C:\Documents and Settings\Current User.erlang.cookie, and C:\Windows.erlang.cookie for RabbitMQ Windows service. 如果windows服务启动了，那么cookie应该在两个地方都有。</p>
<p>另一种方法, 你可以使用在脚本命令 rabbitmq-server 和 rabbitmqctl 中使用选项 “ -setcookie cookie” 来设置cookie.</p>
<p>当cookie配置错误 (例如，不完全相同), RabbitMQ 会记录错误的日志信息像这样 “Connection attempt from disallowed node” and “Could not auto-cluster”.</p>
<h2 id="启动独立节点"><a href="#启动独立节点" class="headerlink" title="启动独立节点"></a>启动独立节点</h2><p>要想建立一个 Cluster ，你就必须对每一个已经存在的 RabbitMQ node 按照 cluster 配置的方式重新进行配置。所以第一步要做的就是在每一个 node 上都常规启动 RabbitMQ 服务:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmq-server -detached</span><br><span class="line">rabbit2$ rabbitmq-server -detached</span><br><span class="line">rabbit3$ rabbitmq-server -detached</span><br></pre></td></tr></table></figure></p>
<p>这样就创建了 3 个独立的 RabbitMQ broker ，在每一个 node 上面，可以通过 cluster_status 命令来确认:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;]&#125;,&#123;running_nodes,[rabbit@rabbit1]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit2]&#125;]&#125;,&#123;running_nodes,[rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit3]&#125;]&#125;,&#123;running_nodes,[rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>通过 rabbitmq-server 脚本命令创建的 RabbitMQ broker 对应的 node 的名字是 rabbit@shorthostname 样式，其中 short node 名字在 Linux 下是小写字母形式（如 rabbit@rabbit1）。如果您是在 Windows 上使用 rabbitmq-server.bat 批处理来执行的上述命令，short node 名字会是大写字母形式（如 rabbit@RABBIT1）。所以， 当你要使用 node 名字时，要注意大小写的问题，因为匹配时要求完全一致。</p>
<h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><p>为了将我们创建的 3 个 node 连接成一个 cluster ，需要将其中两个 node（rabbit@rabbit2 和 rabbit@rabbit3）加入到第三个 node（ rabbit@rabbit1）。 </p>
<p>我们首先把rabbit@rabbit2加入到rabbit@rabbit1集群环境中。停止rabbit@rabbit2机器的RabbitMQ应用并且加入到rabbit@rabbit1集群中，然后重启RabbitMQ应用。注意：加入 cluster 的过程隐式包含了重置 node 的动作，即移除了当前 node 上之前存放的所的资源和数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbit2$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit2 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl join_cluster rabbit@rabbit1</span><br><span class="line">Clustering node rabbit@rabbit2 with [rabbit@rabbit1] ...done.</span><br><span class="line">rabbit2$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbit2 ...done.</span><br></pre></td></tr></table></figure></p>
<p>我们可以从 rabbit@rabbit1 或者 rabbit@rabbit2 上通过命令 cluster_status 看到两个 node 已经加入到同一个 cluster 中了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit1]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>现在我们把rabbit@rabbit3加入到相同的集群环境中，步骤和上面的相同。这次我们将加入 rabbit2 所在的 cluster （其实也是 rabbit1 所在的 cluster）以证明在这种情况下通过哪一个 node 加入 cluster 都是一样的。即只要我们提供了处于某个 cluster 中的可被其他人访问的 node ，那么该 node 所在的 cluster 就可以被其他 node 加入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbit3$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit3 ...done.</span><br><span class="line">rabbit3$ rabbitmqctl join_cluster rabbit@rabbit2</span><br><span class="line">Clustering node rabbit@rabbit3 with rabbit@rabbit2 ...done.</span><br><span class="line">rabbit3$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbit3 ...done.</span><br></pre></td></tr></table></figure></p>
<p>我们可以从任意一个 node 上通过命令 cluster_status 看到三个 node 已经加入到同一个 cluster 中了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit3,rabbit@rabbit2,rabbit@rabbit1]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit3,rabbit@rabbit1,rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit3,rabbit@rabbit2,rabbit@rabbit1]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit1,rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>按照上面的步骤，我们可以在任意时间添加新的 node 到 cluster 中，只要 cluster 处于运行状态。</p>
<h2 id="重启集群节点"><a href="#重启集群节点" class="headerlink" title="重启集群节点"></a>重启集群节点</h2><p>cluster 中的 node 在任何时候都可以被停止。 同样地如果他们崩溃了也是没有任何问题的。在上述两种情况中，cluster 中的其他 node 都可以不受任何影响的继续运行，这些“非正常” node 重新启动后会自动地与 cluster 中的其他 node 取得联系。 </p>
<p>我们手动关闭 rabbit@rabbit1 和 rabbit@rabbit3 后，通过命令查看 cluster 的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl stop</span><br><span class="line">Stopping and halting node rabbit@rabbit1 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit3,rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmqctl stop</span><br><span class="line">Stopping and halting node rabbit@rabbit3 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>现在我们重新启动 node ，并查看 cluster 的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmq-server -detached</span><br><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit1]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmq-server -detached</span><br><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit1,rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit1,rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>有一些重要的注意事项：</p>
<ul>
<li>当整个 cluster 不能工作了，最后一个失效的 node 必须是第一个重新开始工作的那一个。如果这种情况得不到满足，所有 node 将会为最后一个磁盘 node 的恢复等待 30 秒。如果最后一个离线的 node 无法重新上线，我们可以通过命令 forget_cluster_node 将其从 cluster 中移除 - 具体参考 rabbitmqctl 的使用手册。</li>
<li>如果所有的节点在不受控的情况下停止（比如断电），在这种情况下，可以使用force_boot命令使它再次启动 - 具体参考 rabbitmqctl 的使用手册。</li>
</ul>
<h2 id="拆分集群"><a href="#拆分集群" class="headerlink" title="拆分集群"></a>拆分集群</h2><p>当 node 不应该继续存在于一个 cluster 中时，我们需要显式的将这些 node 移除。我们首先从 cluster 中移除 rabbit@rabbit3 ，将其还原为独立运行状态。具体做法为，在 rabbit@rabbit3 上先停止 RabbitMQ 应用，再重置 node ，最后重新启动RabbitMQ 应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbit3$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit3 ...done.</span><br><span class="line">rabbit3$ rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@rabbit3 ...done.</span><br><span class="line">rabbit3$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbit3 ...done.</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，此时仍旧可以通过 list 命令发现 rabbit@rabbit3 仍然作为 node 显示出来。 </p>
<p>在 node 上运行 cluster_status 命令可以发现 rabbit@rabbit3 已经不再是 cluster 中的一员，且已经处于独立运行状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit1]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit3]&#125;]&#125;,&#123;running_nodes,[rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>我们还可以利用远端移除 node 的操作，这在有些情况下是很有用的，比如对无任何反应的 node 的 处理 。例如，我们可以在 rabbit@rabbit2 上执行移除 rabbit@rabbit1 的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit1 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl forget_cluster_node rabbit@rabbit1</span><br><span class="line">Removing node rabbit@rabbit1 from cluster ...</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>注意到，rabbit1 仍旧会认为自己与 rabbit2 处于同一个 cluster 中，但是此时在 rabbit1 上执行 start_app 操作会提示相应错误信息。我们可以将 rabbit1 重置后让它重新运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbit1 ...</span><br><span class="line">Error: inconsistent_cluster: Node rabbit@rabbit1 thinks it&apos;s clustered with node rabbit@rabbit2, but rabbit@rabbit2 disagrees</span><br><span class="line">rabbit1$ rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@rabbit1 ...done.</span><br><span class="line">rabbit1$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@mcnulty ...</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>此时执行 cluster_status 命令可以显示出当前所有 3 个 node 均是作为独立的 RabbitMQ broker 处于运行状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;]&#125;,&#123;running_nodes,[rabbit@rabbit1]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit2]&#125;]&#125;,&#123;running_nodes,[rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit3$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit3]&#125;]&#125;,&#123;running_nodes,[rabbit@rabbit3]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>注意到 rabbit@rabbit2 会保有 cluster 的残余状态信息，而 rabbit@rabbit1 和 rabbit@rabbit3 却可以看成是新初始化的 RabbitMQ broker 。如果我们想要重新初始化 rabbit@rabbit2 ，我们可以按照下面的方式执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbit2$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit2 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@rabbit2 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbit2 ...done.</span><br></pre></td></tr></table></figure></p>
<h2 id="升级集群"><a href="#升级集群" class="headerlink" title="升级集群"></a>升级集群</h2><p>当RabbitMQ从一个版本升级到另一个版本的时候（比如：从3.0.x到3.1.x,或者从2.x.x到3.x.x），或者升级Erlang环境，整个集群必须停止后进行升级（集群不能够运行混合版本）。这里指的不是升级补丁版本的情况（比如：从3.0.x到3.0.y），除非在发行版本中有特殊说明，这些版本是可以在一个集群中混合使用。因此在升级之前强烈建议查看发行版本的说明。</p>
<p>Some patch releases known to require a cluster-wide restart:</p>
<ul>
<li>3.0.0 cannot be mixed with later versions from the 3.0.x series</li>
<li>3.6.6 and later cannot be mixed with earlier versions from the 3.6.x series</li>
<li></li>
</ul>
<p>当 RabbitMQ 从一个版本升级到另一个版本时，如果必要，RabbitMQ 会自动升级持久化数据结构。在 cluster 中，上述工作会由第一个被启动的磁盘 node 进行（即“负责升级的” node ）。所以，当你升级一个 RabbitMQ cluster 的时候，不可以首先启动任何内存 node ，任何内存 node 的启动将产生一条错误消息并且启动失败。 </p>
<p>尽管不是一定必要，但是建议你事先决定好使用哪个磁盘 node 作为升级点（upgrader），然后在升级过程中，最后停止那个 node ，最先启动那个 node 。否则，在 升级点 node 停止和最后停止的 node 之间所做的对于 cluster 配置的修改将会被丢失掉。 </p>
<p>自动升级的功能仅在 RabbitMQ 2.1.1 和之后的版本中才具有。如果你使用了更早版本的 cluster ，你讲需要通过重新构建的方式来升级。</p>
<h2 id="单机上的集群"><a href="#单机上的集群" class="headerlink" title="单机上的集群"></a>单机上的集群</h2><p>在一些情况下，在单机上运行 RabbitMQ node 的 cluster 可能对你很有实用价值。其中之一是，你可以在你的台式机或者笔记本上运行 cluster 而不用额外跑多个虚拟机。</p>
<p>为了在单个主机上运行多个RabbitMQ节点，确保节点具有不同的节点名称，数据存储位置，日志文件位置，并且绑定到不同的端口，包含那些使用的插件，在<a href="http://www.rabbitmq.com/configure.html#define-environment-variables" target="_blank" rel="noopener">配置指南</a>中查看RABBITMQ_NODENAME, RABBITMQ_NODE_PORT, 和 RABBITMQ_DIST_PORT的介绍，以及在文件和目录位置指南中的查看RABBITMQ_MNESIA_DIR, RABBITMQ_CONFIG_FILE, and RABBITMQ_LOG_BASE描述。</p>
<p>你可以反复调用rabbitmq-server脚本在同一个主机上启动多个节点（Windows里面是rabbitmq-server.bat文件），比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit rabbitmq-server -detached</span><br><span class="line">$ RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=hare rabbitmq-server -detached</span><br><span class="line">$ rabbitmqctl -n hare stop_app</span><br><span class="line">$ rabbitmqctl -n hare join_cluster rabbit@`hostname -s`</span><br><span class="line">$ rabbitmqctl -n hare start_app</span><br></pre></td></tr></table></figure></p>
<p>上述步骤将创建2个节点的集群，二者都是作为磁盘节点，注意 如果你想开放其他端口，你可以通过配置那些不冲突的端口运行，通过命令完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ RABBITMQ_NODE_PORT=5672 RABBITMQ_SERVER_START_ARGS=&quot;-rabbitmq_management listener [&#123;port,15672&#125;]&quot; RABBITMQ_NODENAME=rabbit rabbitmq-server -detached</span><br><span class="line">$ RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=&quot;-rabbitmq_management listener [&#123;port,15673&#125;]&quot; RABBITMQ_NODENAME=hare rabbitmq-server -detached</span><br></pre></td></tr></table></figure></p>
<p>上述命令同样建立了两个 node 的 cluster ，但是使用了管理插件。</p>
<h2 id="改变主机名"><a href="#改变主机名" class="headerlink" title="改变主机名"></a>改变主机名</h2><p>RabbitMQ 节点通过主机名来进行通信。因此，所有的节点必须能够解析来自集群中的其他节点。rabbitmqctl也是在这种情况使用。</p>
<p>除此之外，数据库目录使用当前的主机名在系统中使用。如果主机名发生了改变，一个新的空数据库将被创建。为了避免数据丢失创建一个固定的主机名是很重要的。当主机名发生了改变你需要重启RabbitMQ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/rabbitmq-server restart</span><br></pre></td></tr></table></figure></p>
<p>A similar effect can be achieved by using rabbit@localhost as the broker nodename. The impact of this solution is that clustering will not work, because the chosen hostname will not resolve to a routable address from remote hosts. The rabbitmqctl command will similarly fail when invoked from a remote host. A more sophisticated solution that does not suffer from this weakness is to use DNS, e.g. Amazon Route 53 if running on EC2. If you want to use the full hostname for your nodename (RabbitMQ defaults to the short name), and that full hostname is resolveable using DNS, you may want to investigate setting the environment variable RABBITMQ_USE_LONGNAME=true.</p>
<p>查看<a href="http://www.rabbitmq.com/clustering.html#overview-hostname-requirements" target="_blank" rel="noopener">hostname resolution guide</a>获取更多的信息。</p>
<h2 id="防火墙后的节点"><a href="#防火墙后的节点" class="headerlink" title="防火墙后的节点"></a>防火墙后的节点</h2><p>这种情况是指数据中心或者可靠网络上的 cluster 中的 node 彼此之间存在防火墙的情况。再一次重申，不建议在 WAN 或者 node 之间的网络连接不可靠的情况下创建 cluster 。 </p>
<p>在最常见的配置中，您将需要打开多个标准端口：</p>
<ol>
<li>4369 (epmd)</li>
<li>5672, 5671 (AMQP 0-9-1 and 1.0 without and with TLS)</li>
<li><ol start="25672">
<li>This port used by Erlang distribution for inter-node and CLI tools communication and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). See networking guide for details.</li>
</ol>
</li>
<li>15672 (if management plugin is enabled)</li>
<li>61613, 61614 (if STOMP is enabled)</li>
<li>1883, 8883 (if MQTT is enabled)</li>
</ol>
<p>查看 <a href="http://www.rabbitmq.com/networking.html" target="_blank" rel="noopener">RabbitMQ Networking guide</a>获取更详细的信息.</p>
<h2 id="集群中的Erlang版本"><a href="#集群中的Erlang版本" class="headerlink" title="集群中的Erlang版本"></a>集群中的Erlang版本</h2><p>所有节点都必须运行在相同版本的erlang环境。</p>
<h2 id="从客户端连接到集群"><a href="#从客户端连接到集群" class="headerlink" title="从客户端连接到集群"></a>从客户端连接到集群</h2><p>客户端可以透明地连接到 cluster 中的任意一个 node 上。 如果当前与客户端处于连接状态的那个 node 失效了，但是 cluster 中的其他 node 正常工作，那么客户端应该发现当前连接的关闭，然后应该可以重新连接到 cluster 中的其他正常的 node 上。一般来讲，将 node 的主机名或者 IP 地址 硬编码 到客户端应用程序中是非常不明智的：这会导致各种坑爹问题的出现，因为一旦 cluster 的配置改变或者 cluster 中的 ndoe 数目改变，客户端将面临重新编码、编译和重新发布的问题。作为替代，我们建议一种更加一般化的方式：采用 动态 DNS 服务 ，其具有非常短的 TTL 配置，或者 普通 TCP 负载均衡器 ，或者通过随机行走或者类似技术实现的某种形式的 mobile IP 。通常来讲，关于如何成功连接 cluster 中的 node 已经超出了 RabbitMQ 本身要说明的范畴，我们建议你使用其他的专门用于处理这方面问题的技术来解决这种问题。 </p>
<h2 id="带内存节点的集群"><a href="#带内存节点的集群" class="headerlink" title="带内存节点的集群"></a>带内存节点的集群</h2><p>RAM nodes keep their metadata only in memory. As RAM nodes don’t have to write to disc as much as disc nodes, they can perform better. However, note that since persistent queue data is always stored on disc, the performance improvements will affect only resource management (e.g. adding/removing queues, exchanges, or vhosts), but not publishing or consuming speed.</p>
<p>RAM nodes are an advanced use case; when setting up your first cluster you should simply not use them. You should have enough disc nodes to handle your redundancy requirements, then if necessary add additional RAM nodes for scale.</p>
<p>A cluster containing only RAM nodes is fragile; if the cluster stops you will not be able to start it again and will lose all data. RabbitMQ will prevent the creation of a RAM-node-only cluster in many situations, but it can’t absolutely prevent it.</p>
<p>The examples here show a cluster with one disc and one RAM node for simplicity only; such a cluster is a poor design choice.</p>
<h3 id="创建内存节点"><a href="#创建内存节点" class="headerlink" title="创建内存节点"></a>创建内存节点</h3><p>我们可以声明一个内存节点加入到集群环境中，我们在使用rabbitmqctl join_cluster命令之，加上 –ram 标签即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbit2$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit2 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">Clustering node rabbit@rabbit2 with [rabbit@rabbit1] ...done.</span><br><span class="line">rabbit2$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbit2 ...done.</span><br></pre></td></tr></table></figure></p>
<p>内存节点在cluster status中显示效果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rabbit1$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit2,rabbit@rabbit1]&#125;]</span><br><span class="line">...done.</span><br><span class="line">rabbit2$ rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;]</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<h3 id="改变节点类型"><a href="#改变节点类型" class="headerlink" title="改变节点类型"></a>改变节点类型</h3><p>我们可以改变 node 的类型，如磁盘 node 到内存 node ，或者相反。比如将 rabbit@rabbit2 和 rabbit@rabbit3 的 node 类型都变成和之前不同的种类。我们可以使用命令 change_cluster_node_type 来进行转换，但是首先需要将 node 停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rabbit2$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit2 ...done.</span><br><span class="line">rabbit2$ rabbitmqctl change_cluster_node_type disc</span><br><span class="line">Turning rabbit@rabbit2 into a disc node ...</span><br><span class="line">...done.</span><br><span class="line">Starting node rabbit@rabbit2 ...done.</span><br><span class="line">rabbit1$ rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@rabbit1 ...done.</span><br><span class="line">rabbit1$ rabbitmqctl change_cluster_node_type ram</span><br><span class="line">Turning rabbit@rabbit1 into a ram node ...</span><br><span class="line">rabbit1$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbit1 ...done.</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/23/RabbitMQ-Installing-on-Generic-Unix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/23/RabbitMQ-Installing-on-Generic-Unix/" itemprop="url">
                  RabbitMQ Installing on Generic Unix
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-23 22:38:26" itemprop="dateCreated datePublished" datetime="2016-09-23T22:38:26+08:00">2016-09-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/23/RabbitMQ-Installing-on-Generic-Unix/" class="leancloud_visitors" data-flag-title="RabbitMQ Installing on Generic Unix">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务下载"><a href="#服务下载" class="headerlink" title="服务下载"></a>服务下载</h2><table>
<thead>
<tr>
<th>Description</th>
<th>Download</th>
</tr>
</thead>
<tbody>
<tr>
<td>Generic Unix release (tar.xz, from rabbitmq.com)</td>
<td><a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-generic-unix-3.6.5.tar.xz" target="_blank" rel="noopener">rabbitmq-server-generic-unix-3.6.5.tar.xz</a></td>
</tr>
</tbody>
</table>
<h2 id="Generic-Unix-or-Linux-BSD-Mac-OS-X"><a href="#Generic-Unix-or-Linux-BSD-Mac-OS-X" class="headerlink" title="Generic Unix or Linux (BSD, Mac OS X)"></a>Generic Unix or Linux (BSD, Mac OS X)</h2><h3 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h3><p>安装最新的<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang</a>版本。<br>从上面的连接下载rabbitmq-server-generic-unix-3.6.5.tar.xz。</p>
<p>在这个压缩文件中有一个目录名为rabbitmq_server-3.6.5。对该文件进行解压操作，我们在rabbitmq_server-3.6.5将会找到sbin目录。</p>
<h2 id="运行RabbitMQ服务"><a href="#运行RabbitMQ服务" class="headerlink" title="运行RabbitMQ服务"></a>运行RabbitMQ服务</h2><p><strong>启动服务</strong><br>　　调用sbin/rabbitmq-server shell脚本。这里会显示一条banner消息内容<br>，结束的时候会显示”completed with [n] plugins.”的内容，这表明RabbitMQ已经启动成功。<br>　　你也可以在后台运行服务，使用命令rabbitmq-server -detached，这种情况下服务进程会在后台运行。<br><strong>配置服务</strong><br>你可以在\$RABBITMQ_HOME/etc/rabbitmq/rabbitmq-env.conf文件中设置RabbitMQ的环境变量信息。服务器组件也能够配置，这个RabbitMQ配置文件路径在$RABBITMQ_HOME/etc/rabbitmq/rabbitmq.config。安装后这两个文件本身是不存在的。</p>
<h2 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h2><p>这个通用的Unix版本被设计成可以直接运行，不需要改变配置或者指定权限。这个目录和文件信息默认都是安装在rabbitmq_server-3.6.5目录中，在脚本文件中使用$RABBITMQ_HOME环境变量来代替这个路径。</p>
<p>如果你希望安装的RabbitMQ服务是使用传统的系统目录方式来管理配置，数据库，日志文件，插件配置等，这也是允许的。</p>
<p>找到这行配置信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_PREFIX=<span class="variable">$&#123;RABBITMQ_HOME&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在sbin/rabbitmq-defaults文件中去改变这行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_PREFIX=</span><br></pre></td></tr></table></figure></p>
<p>不要在这个文件中修改其他行的内容。</p>
<p>备注：在修改了这个默认的目录后也许需要不同的权限才能够工作。RABBITMQ_MNESIA_BASE和RABBITMQ_LOG_BASE需要创建权限（服务器在启动的时候会创建），RABBITMQ_ENABLED_PLUGINS_FILE 需要写权限（针对rabbitmq-plugins）。这个配置文件可以在/etc/rabbitmq/里面进行查看。</p>
<h2 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h2><p>SELinux and similar 机器也许会阻止RabbitMQ绑定端口。这种情况下，RabbitMQ将会启动失败。确保以下端口是被允许打开的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4369 (epmd), 25672 (Erlang distribution)</span><br><span class="line">5672, 5671 (AMQP 0-9-1 without and with TLS)</span><br><span class="line">15672 (<span class="keyword">if</span> management plugin is enabled)</span><br><span class="line">61613, 61614 (<span class="keyword">if</span> STOMP is enabled)</span><br><span class="line">1883, 8883 (<span class="keyword">if</span> MQTT is enabled)</span><br></pre></td></tr></table></figure></p>
<p>可以配置<a href="http://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">RabbitMQ</a>使用其他端口。</p>
<h2 id="默认用户访问"><a href="#默认用户访问" class="headerlink" title="默认用户访问"></a>默认用户访问</h2><p>这个服务创建了一个用户名guest密码为guest的用户。没有配置的客户端将采用这个用户。默认情况下这个凭证只能用于连接本机。</p>
<p>查看文档中访问控制信息。了解如何创建更多的用户、删除guest用户，或者允许guest用户进行远程访问。</p>
<h2 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h2><p>怎么停止服务或者检查它的状态等，你可以调用sbin/rabbitmqctl(作为运行rabbitmq-server的用户来操作)。如果没有服务在运行rabbitmqctl命令将报告节点不在线的信息。</p>
<ul>
<li>调用 rabbitmqctl stop 命令停止服务.</li>
<li>调用 rabbitmqctl status 检查服务运行状态.</li>
</ul>
<p>更多的信息查看<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html" target="_blank" rel="noopener">rabbitmqctl</a></p>
<h2 id="控制系统的限制"><a href="#控制系统的限制" class="headerlink" title="控制系统的限制"></a>控制系统的限制</h2><p>RabbitMQ安装运行在生产环境的工作负载情况下需要对系统的内核参数限制进行调整，保证一个合适的数量来处理并发的连接和队列。这里主要设置打开文件的最大数量，可以使用这个命令 ulimit -n。许多操作系统作为一个消息代理来说这个默认值太低了（大部分的linux默认值都是1024）。我们推荐使用最少65536的文件描述符作为用户rabbitmq的生产环境，4096 基本上满足大多数开发工作负载。</p>
<p>这里有2个限制参数：最大允许打开的文件数(fs.file-max on Linux, kern.maxfilesperproc on OS X and FreeBSD)和per-user 限制数(ulimit -n)。前者必须高于后者。</p>
<p>更多关于控制系统限制的信息，请参考<a href="http://docs.basho.com/riak/latest/ops/tuning/open-files-limit/" target="_blank" rel="noopener"> Riak guide on open file limit tuning.</a></p>
<h2 id="验证限制"><a href="#验证限制" class="headerlink" title="验证限制"></a>验证限制</h2><p><a href="http://www.rabbitmq.com/management.html" target="_blank" rel="noopener">UI管理页面</a> 在概述这个选项卡里显示了可用的文件描述符数量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure></p>
<p>上面的信息也包含了同样的值。<br>这个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br></pre></td></tr></table></figure></p>
<p>能够显示当前用户的限制数。There may be more convenient OS-specific ways of doing that for a running process, such as the /proc filesystem on Linux.</p>
<p>##配置管理工具<br>配置管理工具(比如：Chef, Puppet, BOSH)提供了对系统限制的调整。我们的<a href="http://www.rabbitmq.com/devtools.html#devops-tools" target="_blank" rel="noopener">开发工具</a>指南里面列出了相关的模块和项目。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/21/RabbitMQ-Tutorials-RPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/21/RabbitMQ-Tutorials-RPC/" itemprop="url">
                  RabbitMQ Tutorials (RPC)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-21 22:37:26" itemprop="dateCreated datePublished" datetime="2016-09-21T22:37:26+08:00">2016-09-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/21/RabbitMQ-Tutorials-RPC/" class="leancloud_visitors" data-flag-title="RabbitMQ Tutorials (RPC)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="远程过程调用-RPC"><a href="#远程过程调用-RPC" class="headerlink" title="远程过程调用 (RPC)"></a>远程过程调用 (RPC)</h2><p>在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。</p>
<p>可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者RPC。</p>
<p>这篇教程中，我们会使用RabbitMQ来构建一个RPC系统：包含一个客户端和一个RPC服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。</p>
<h2 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h2><p>为了展示RPC服务如何使用，我们创建了一个简单的客户端类。它会暴露出一个名为“call”的方法用来发送一个RPC请求，并且在收到回应前保持阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FibonacciRpcClient fibonacciRpc = <span class="keyword">new</span> FibonacciRpcClient();   </span><br><span class="line">String result = fibonacciRpc.call(<span class="string">"4"</span>);</span><br><span class="line">System.out.println( <span class="string">"fib(4) is "</span> + result);</span><br></pre></td></tr></table></figure>
<p><strong>关于RPC的注意事项：</strong></p>
<p>尽管RPC在计算领域是一个常用模式，但它也经常被诟病。当一个问题被抛出的时候，程序员往往意识不到这到底是由本地调用还是由较慢的RPC调用引起的。同样的困惑还来自于系统的不可预测性和给调试工作带来的不必要的复杂性。跟软件精简不同的是，滥用RPC会导致不可维护的代码.</p>
<p>考虑到这一点，牢记以下建议：</p>
<ul>
<li>确保能够明确的搞清楚哪个函数是本地调用的，哪个函数是远程调用的。</li>
<li>给你的系统编写文档。保持各个组件间的依赖明确。处理错误案例。</li>
<li>明了客户端改如何处理RPC服务器的宕机和长时间无响应情况。</li>
</ul>
<p>当对避免使用RPC有疑问的时候。如果可以的话，你应该尽量使用异步管道来代替RPC类的阻塞。结果被异步地推送到下一个计算场景。</p>
<h2 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h2><p>一般来说通过RabbitMQ来实现RPC是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址。我们使用默认的队列。来尝试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">callbackQueueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">BasicProperties props = <span class="keyword">new</span> BasicProperties</span><br><span class="line">                            .Builder()</span><br><span class="line">                            .replyTo(callbackQueueName)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"rpc_queue"</span>, props, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... then code to read a response message from the callback_queue ...</span></span><br></pre></td></tr></table></figure></p>
<p><strong>消息属性</strong></p>
<p>AMQP协议给消息预定义了一系列的14个属性。大多数属性很少会用到，除了以下几个：</p>
<ul>
<li>delivery_mode（投递模式）：将消息标记为持久的（值为2）或暂存的（除了2之外的其他任何值）。第二篇教程里接触过这个属性，记得吧？</li>
<li>content_type（内容类型）:用来描述编码的mime-type。例如在实际使用中常常使用application/json来描述JOSN编码类型。</li>
<li>reply_to（回复目标）：通常用来命名回调队列。</li>
<li>correlation_id（关联标识）：用来将RPC的响应和请求关联起来。</li>
</ul>
<p>我们需要导入这个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP.BasicProperties;</span><br></pre></td></tr></table></figure></p>
<h2 id="关联标识"><a href="#关联标识" class="headerlink" title="关联标识"></a>关联标识</h2><p>上边介绍的方法中，我们建议给每一个RPC请求新建一个回调队列。这不是一个高效的做法，幸好这儿有一个更好的办法 —— 我们可以为每个客户端只建立一个独立的回调队列。</p>
<p>这就带来一个新问题，当此队列接收到一个响应的时候它无法辨别出这个响应是属于哪个请求的。correlation_id 就是为了解决这个问题而来的。我们给每个请求设置一个独一无二的值。稍后，当我们从回调队列中接收到一个消息的时候，我们就可以查看这条属性从而将响应和请求匹配起来。如果我们接手到的消息的correlation_id是未知的，那就直接销毁掉它，因为它不属于我们的任何一条请求。</p>
<p>你也许会问，为什么我们接收到未知消息的时候不抛出一个错误，而是要将它忽略掉？这是为了解决服务器端有可能发生的竞争情况。尽管可能性不大，但RPC服务器还是有可能在已将应答发送给我们但还未将确认消息发送给请求的情况下死掉。如果这种情况发生，RPC在重启后会重新处理请求。这就是为什么我们必须在客户端优雅的处理重复响应，同时RPC也需要尽可能保持幂等性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-six.png" alt=""></p>
<p>我们的RPC如此工作:</p>
<ul>
<li>当客户端启动的时候，它创建一个匿名独享的回调队列。</li>
<li>在RPC请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。</li>
<li>将请求发送到一个 rpc_queue 队列中。</li>
<li>RPC工作者（又名：服务器）等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给reply_to字段指定的队列。</li>
<li>客户端等待回调队列里的数据。当有消息出现的时候，它会检查correlation_id属性。如果此属性的值与请求匹配，将它返回给应用。</li>
</ul>
<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><p>这是斐波那契方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们声明了fibonacci函数，我们假设输入了一个有效的整数值。（别指望这个函数能处理很大的数值，会使得这个递归非常的慢）。</p>
<p>我们的RPC服务程序<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCServer.java" target="_blank" rel="noopener">RPCServer.java</a>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE_NAME = <span class="string">"rpc_queue"</span>;</span><br><span class="line"></span><br><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">channel.queueDeclare(RPC_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">channel.basicConsume(RPC_QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">" [x] Awaiting RPC requests"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line"></span><br><span class="line">    BasicProperties props = delivery.getProperties();</span><br><span class="line">    BasicProperties replyProps = <span class="keyword">new</span> BasicProperties</span><br><span class="line">                                     .Builder()</span><br><span class="line">                                     .correlationId(props.getCorrelationId())</span><br><span class="line">                                     .build();</span><br><span class="line"></span><br><span class="line">    String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">    <span class="keyword">int</span> n = Integer.parseInt(message);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [.] fib("</span> + message + <span class="string">")"</span>);</span><br><span class="line">    String response = <span class="string">""</span> + fib(n);</span><br><span class="line"></span><br><span class="line">    channel.basicPublish( <span class="string">""</span>, props.getReplyTo(), replyProps, response.getBytes());</span><br><span class="line"></span><br><span class="line">    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务器端代码相当简单：</p>
<ul>
<li>像往常一样，我们建立连接，声明队列。</li>
<li>或许我们希望能在服务器上多开几个线程。为了能将负载平均地分摊到多个服务器，我们需要将 prefetch_count 设置好。</li>
<li>我们为 basic_consume 声明了一个回调函数，这是RPC服务器端的核心。它执行实际的操作并且作出响应。</li>
</ul>
<p>RPC客户端程序 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCClient.java" target="_blank" rel="noopener">RPCClient.java</a>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection connection;</span><br><span class="line"><span class="keyword">private</span> Channel channel;</span><br><span class="line"><span class="keyword">private</span> String requestQueueName = <span class="string">"rpc_queue"</span>;</span><br><span class="line"><span class="keyword">private</span> String replyQueueName;</span><br><span class="line"><span class="keyword">private</span> QueueingConsumer consumer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    connection = factory.newConnection();</span><br><span class="line">    channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    replyQueueName = channel.queueDeclare().getQueue(); </span><br><span class="line">    consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">    channel.basicConsume(replyQueueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">    String response = <span class="keyword">null</span>;</span><br><span class="line">    String corrId = java.util.UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    BasicProperties props = <span class="keyword">new</span> BasicProperties</span><br><span class="line">                                .Builder()</span><br><span class="line">                                .correlationId(corrId)</span><br><span class="line">                                .replyTo(replyQueueName)</span><br><span class="line">                                .build();</span><br><span class="line"></span><br><span class="line">    channel.basicPublish(<span class="string">""</span>, requestQueueName, props, message.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">        <span class="keyword">if</span> (delivery.getProperties().getCorrelationId().equals(corrId)) &#123;</span><br><span class="line">            response = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端代码稍微有点难懂：</p>
<ul>
<li>我们建立了一个连接和通道，声明了一个回调队列作为回复。</li>
<li>我们订阅这个回调队列，以便接收RPC的响应。</li>
<li>我们定义我们的回调方法call。它执行真正的RPC请求。</li>
<li>在这个方法中，首先我们生成一个唯一的 correlation_id 值并且保存起来，回调函数会用它来获取符合要求的响应。</li>
<li>接下来，我们将带有 replyTo  和 correlationId 属性的消息发布出去。</li>
<li>现在我们可以坐下来，等待正确的响应到来。</li>
<li>最后，我们将响应返回给用户。</li>
</ul>
<p>客户端的请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RPCClient fibonacciRpc = <span class="keyword">new</span> RPCClient();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">" [x] Requesting fib(30)"</span>);   </span><br><span class="line">String response = fibonacciRpc.call(<span class="string">"30"</span>);</span><br><span class="line">System.out.println(<span class="string">" [.] Got '"</span> + response + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">fibonacciRpc.close();</span><br></pre></td></tr></table></figure></p>
<p>现在我们来看看完整的源码<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCClient.java" target="_blank" rel="noopener">RPCClient.java</a> and <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCServer.java" target="_blank" rel="noopener">RPCServer.java</a>.</p>
<p>和之前一样编译程序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -cp rabbitmq-client.jar RPCClient.java RPCServer.java</span><br></pre></td></tr></table></figure></p>
<p>我们的RPC服务已经准备就绪了，现在启动服务器端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> RPCServer</span><br><span class="line"> [x] Awaiting RPC requests</span><br></pre></td></tr></table></figure></p>
<p>运行客户端，请求一个fibonacci队列:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> RPCClient</span><br><span class="line"> [x] Requesting fib(30)</span><br></pre></td></tr></table></figure></p>
<p>此处呈现的设计并不是实现RPC服务的唯一方式，但是他有一些重要的优势：</p>
<ul>
<li>如果RPC服务器运行的过慢的时候，你可以通过运行另外一个服务器端轻松扩展它。试试在控制台中运行第二个 RPCServer  。</li>
<li>在客户端，RPC请求只发送或接收一条消息。不需要像 queue_declare 这样的异步调用。所以RPC客户端的单个请求只需要一个网络往返。</li>
</ul>
<p>我们的代码依旧非常简单，而且没有试图去解决一些复杂（但是重要）的问题，如：</p>
<ul>
<li>当没有服务器运行时，客户端如何作出反映。</li>
<li>客户端是否需要实现类似RPC超时的东西。</li>
<li>如果服务器发生故障，并且抛出异常，应该被转发到客户端吗？</li>
<li>在处理前，防止混入无效的信息（例如检查边界）</li>
</ul>
<p>如果你想做一些实验，你会发现rabbitmq-management plugin在观测队列方面是很有用处的。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/19/RabbitMQ-Tutorials-Topics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/19/RabbitMQ-Tutorials-Topics/" itemprop="url">
                  RabbitMQ Tutorials (Topics)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-19 22:37:26" itemprop="dateCreated datePublished" datetime="2016-09-19T22:37:26+08:00">2016-09-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/19/RabbitMQ-Tutorials-Topics/" class="leancloud_visitors" data-flag-title="RabbitMQ Tutorials (Topics)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Topics-主题"><a href="#Topics-主题" class="headerlink" title="Topics(主题)"></a>Topics(主题)</h2><p>上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为可以选择性的接收日志。</p>
<p>尽管直连交换机能够改善我们的系统，但是它也有它的限制 —— 没办法基于多个标准执行路由操作。</p>
<p>在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix工具syslog就是同时基于严重程度-severity (info/warn/crit…) 和 设备-facility (auth/cron/kern…)来路由日志的。</p>
<p>如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于“cron”的严重程度为“critical errors”的日志，也可以监听来源于“kern”的所有日志。</p>
<p>为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。</p>
<h2 id="Topic-exchange"><a href="#Topic-exchange" class="headerlink" title="Topic exchange"></a>Topic exchange</h2><p>发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由.分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。词语的个数可以随意，但是不要超过255字节。</p>
<p>绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：</p>
<ul>
<li>*(星号) 用来表示一个单词.</li>
<li>#(井号) 用来表示任意数量（零个或多个）单词。</li>
</ul>
<p>用图来表示：<br><img src="http://www.rabbitmq.com/img/tutorials/python-five.png" alt=""></p>
<p>这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个.分割开。路由键里的第一个单词描述的是动物的敏捷，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： <celerity>.<colour>.<species>。</species></colour></celerity></p>
<p>我们创建了三个绑定：Q1的绑定键为 <em>.orange.</em>，Q2的绑定键为 <em>.</em>.rabbit 和 lazy.# 。</p>
<p>这三个绑定键被可以总结为：</p>
<ul>
<li>Q1 对所有的桔黄色动物都感兴趣。</li>
<li>Q2 则是对所有的兔子和所有懒惰的动物感兴趣</li>
</ul>
<p>一个携带有 quick.orange.rabbit 的消息将会被分别投递给这两个队列。携带着 lazy.orange.elephant 的消息同样也会给两个队列都投递过去。另一方面携带有 quick.orange.fox 的消息会投递给第一个队列，携带有 lazy.brown.fox 的消息会投递给第二个队列。携带有 lazy.pink.rabbit 的消息只会被投递给第二个队列一次，即使它同时匹配第二个队列的两个绑定。携带着 quick.brown.fox 的消息不会投递给任何一个队列。</p>
<p>如果我们违反约定，发送了一个携带有一个单词或者四个单词（”orange” or “quick.orange.male.rabbit”）的消息时，发送的消息不会投递给任何一个队列，而且会丢失掉。</p>
<p>但是另一方面，即使 “lazy.orange.male.rabbit” 有四个单词，他还是会匹配最后一个绑定，并且被投递到第二个队列中。</p>
<p><strong>主题交换机</strong></p>
<p>主题交换机是很强大的，它可以表现出跟其他交换机类似的行为</p>
<p>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。</p>
<p>当 * (星号) 和 # (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。</p>
<h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>接下来我们会将主题交换机应用到我们的日志系统中。在开始工作前，我们假设日志的路由键由两个单词组成，路由键看起来是这样的：<facility>.<severity>。</severity></facility></p>
<p>代码跟上一篇教程差不多。</p>
<p>EmitLogTopic.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        String routingKey = getRouting(argv);</span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + routingKey + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReceiveLogsTopic.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">"Usage: ReceiveLogsTopic [binding_key]..."</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String bindingKey : argv) &#123;</span><br><span class="line">      channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + envelope.getRoutingKey() + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run the following examples, including the classpath as in Tutorial 1 - on Windows, use %CP%.<br>To receive all the logs:<br>运行这个例子，和之前一样使用了%CP%环境变量。<br>接收所有的日志信息写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> ReceiveLogsTopic <span class="string">"#"</span></span><br></pre></td></tr></table></figure></p>
<p>接收来自”kern“设备的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> ReceiveLogsTopic <span class="string">"kern.*"</span></span><br></pre></td></tr></table></figure></p>
<p>只接收严重程度为”critical“的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> ReceiveLogsTopic <span class="string">"*.critical"</span></span><br></pre></td></tr></table></figure></p>
<p>建立多个绑定：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> ReceiveLogsTopic <span class="string">"kern.*"</span> <span class="string">"*.critical"</span></span><br></pre></td></tr></table></figure></p>
<p>发送路由键为 “kern.critical” 的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> EmitLogTopic <span class="string">"kern.critical"</span> <span class="string">"A critical kernel error"</span></span><br></pre></td></tr></table></figure></p>
<p>执行上边命令试试看效果吧。另外，上边代码不会对路由键和绑定键做任何假设，所以你可以在命令中使用超过两个路由键参数。</p>
<p>思考以下问题：</p>
<ul>
<li><p>绑定键为 * 的队列会取到一个路由键为空的消息吗？<br>不会</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ReceiveLogsTopic <span class="string">"*"</span></span><br><span class="line">./EmitLogTopic <span class="string">""</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定键为 #.* 的队列会获取到一个名为..的路由键的消息吗？<br>不会</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ReceiveLogsTopic <span class="string">"#.*"</span></span><br><span class="line">./EmitLogTopic <span class="string">".."</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>它会取到一个路由键为单个单词的消息吗？<br>会</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ReceiveLogsTopic <span class="string">"#.*"</span></span><br><span class="line">./EmitLogTopic <span class="string">"a"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>a.*.# 和 a.#的区别在哪儿？</p>
</li>
</ul>
<p>‘a.*.#’匹配2个单词以上的情况，并且第一个单词是’a’.开头的。’a.#’匹配的是一个单词以上的，第一个单词是’a’.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./ReceiveLogsTopic <span class="string">"a.*.#"</span></span><br><span class="line">./EmitLogTopic <span class="string">"a.b"</span></span><br><span class="line">./ReceiveLogsTopic <span class="string">"a.#"</span></span><br><span class="line">./EmitLogTopic <span class="string">"a.b"</span></span><br></pre></td></tr></table></figure></p>
<p>(完整的代码 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/EmitLogTopic.java" target="_blank" rel="noopener">EmitLogTopic.java</a> and <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/ReceiveLogsTopic.java" target="_blank" rel="noopener">ReceiveLogsTopic.java</a>)</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/18/RabbitMQ-Tutorials-Routing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/18/RabbitMQ-Tutorials-Routing/" itemprop="url">
                  RabbitMQ Tutorials (Routing)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-18 22:54:41" itemprop="dateCreated datePublished" datetime="2016-09-18T22:54:41+08:00">2016-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/18/RabbitMQ-Tutorials-Routing/" class="leancloud_visitors" data-flag-title="RabbitMQ Tutorials (Routing)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Routing-路由"><a href="#Routing-路由" class="headerlink" title="Routing(路由)"></a>Routing(路由)</h2><p>上一节，我们创建了一个日志系统，我们能够分发log信息给每个订阅者。</p>
<p>这一节，我们在其上添加额外的功能——只订阅log信息的一个子集。例如：我们只把至关重要的错误日志信息，记录到文件，而所有的日志信息都可以在控制带输出。</p>
<h2 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h2><p>上一节，我们已经定义了绑定信息，你可以回想一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br></pre></td></tr></table></figure></p>
<p>binding是exchange与queue之间的关系，简单的来说就是:queue对来自指定的exchange的消息感兴趣。</p>
<p>Binding可以指定routingKey参数。为了避免和BasicPublish参数疑惑，我们可以叫它 binding key。因此我们可以创建一个带key的bingding。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"black"</span>);</span><br></pre></td></tr></table></figure></p>
<p>bingding key的意义取决于 exchange的类型。fanout类型的exchange会忽略这个值。</p>
<h2 id="Direct-exchange"><a href="#Direct-exchange" class="headerlink" title="Direct exchange"></a>Direct exchange</h2><p>上一节的日志系统只能把素有的消息广播给所有的消费者。我们想根据message的log lever来过滤message。例如，我们只想把错误的日志信息写到磁盘里,警告和信息日志不写到磁盘里。</p>
<p>但是fanout类型exchange 不够灵活，它只能盲目的进行广播。</p>
<p>因此这里我们使用 direct类型的exchange来替代。direct 类型exchange背后的算法很简单——一个消息只会发送给queue的bingding key 完全匹配message的routing key的队列。</p>
<p>大体结构如下所示：<br><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt=""></p>
<p>我们看到 direct类型的exchange X 有两个queue绑定到它。第一个 bingding key是orange。第二个有两个bingding Key：black和green。</p>
<p>因此，如果一个message的routing key是orange会发送给Q1队列，如果是blcak或green则会发送给Q2，其他的消息则会被丢弃掉。</p>
<h2 id="Multiple-bindings"><a href="#Multiple-bindings" class="headerlink" title="Multiple bindings"></a>Multiple bindings</h2><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange-multiple.png" alt=""></p>
<p>多个队列绑定同样的key是合法的。我们可以给Q1绑定一个black的key，在这种情况下，direct 类型的exchage的行为和fanout表现的一样。一个消息将会路由给Q1和Q2。</p>
<h2 id="Emitting-logs"><a href="#Emitting-logs" class="headerlink" title="Emitting logs"></a>Emitting logs</h2><p>我们将使用这个模型作为我们的日志系统。我们通过使用一个direct exchange类型来发送消息，代替之前的fanout类型。我们通过日志的级别来作为routing key。订阅者可以通过选择severity来得到他们想要接收的信息。我们首先关注emitting logs。</p>
<p>和之前一样，我们需要先创建一个交换机：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br></pre></td></tr></table></figure></p>
<p>接着我们发送一条消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, severity, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure></p>
<p>为了简化，我们的serverity 可以是”info”,”warning”,”error”。</p>
<h2 id="Subscribing-订阅"><a href="#Subscribing-订阅" class="headerlink" title="Subscribing(订阅)"></a>Subscribing(订阅)</h2><p>接收消息的工作和之前的教程一样，只有一处不一样-我们会循环severity来创建绑定信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String severity : argv)&#123;    </span><br><span class="line">  channel.queueBind(queueName, EXCHANGE_NAME, severity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-four.png" alt=""></p>
<p>EmitLogDirect.java 类的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line"></span><br><span class="line">        String severity = getSeverity(argv);</span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, severity, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + severity + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReceiveLogsDirect.java类的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">      System.err.println(<span class="string">"Usage: ReceiveLogsDirect [info] [warning] [error]"</span>);</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String severity : argv)&#123;</span><br><span class="line">      channel.queueBind(queueName, EXCHANGE_NAME, severity);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + envelope.getRoutingKey() + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译还是和以前一样，为了方便我们使用环境变量$CP(window使用%CP%)作为例子的运行路径：</p>
<p>如果你只想保存 ‘warning’和’error’(不需要’info’)日志信息到文件中，打开控制台并制定类型：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> ReceiveLogsDirect warning error &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure></p>
<p>如果你想在你的屏幕上查看所有的日志信息，打开一个新的终端输入以下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> ReceiveLogsDirect info warning error</span><br><span class="line"> [*] Waiting <span class="keyword">for</span> logs. To <span class="built_in">exit</span> press CTRL+C</span><br></pre></td></tr></table></figure></p>
<p>我们发送一个错误日志信息试试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp <span class="variable">$CP</span> EmitLogDirect error <span class="string">"Run. Run. Or it will explode."</span></span><br><span class="line"> [x] Sent <span class="string">'error'</span>:<span class="string">'Run. Run. Or it will explode.'</span></span><br></pre></td></tr></table></figure></p>
<p>(完整的代码 (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/EmitLogDirect.java" target="_blank" rel="noopener">EmitLogDirect.java source</a>) and (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/ReceiveLogsDirect.java" target="_blank" rel="noopener">ReceiveLogsDirect.java source</a>))</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/18/RabbitMQ-Tutorials-Publish-Subscribe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/18/RabbitMQ-Tutorials-Publish-Subscribe/" itemprop="url">
                  RabbitMQ Tutorials (Publish/Subscribe)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-18 19:54:41" itemprop="dateCreated datePublished" datetime="2016-09-18T19:54:41+08:00">2016-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/18/RabbitMQ-Tutorials-Publish-Subscribe/" class="leancloud_visitors" data-flag-title="RabbitMQ Tutorials (Publish/Subscribe)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><p>在上一节我们创建了一个工作队列。工作队列会按顺序分配给每一个工作者。在这一节里我们会把一条消息给多个消费者。这种模式叫做”发布/订阅”。</p>
<p>为了阐明这种模式，我们建立一个日志系统。它包含两个程序 – 一个发出日志消息，另一个接收并打印日志消息。</p>
<p>在这个日志系统中，每一个receiver程序都会获得日志信息。因此我们可以设置一个接收者直接保存日志信息到硬盘，另一个接收者打印日志信息到屏幕。</p>
<p>就是说，发布的日志消息会广播给所有的接收者。</p>
<h2 id="Exchanges-交换机"><a href="#Exchanges-交换机" class="headerlink" title="Exchanges(交换机)"></a>Exchanges(交换机)</h2><p>上一节我们从一个队列里发送和接收消息。现在我们完整的讲解Rabbit的消息发送模型。<br>我们快速的回顾一下之前的接收流程：</p>
<ul>
<li>一个生产者通过程序发送消息</li>
<li>一个队列作为缓冲区存储消息</li>
<li>一个消费者通过程序接收消息</li>
</ul>
<p>RabbitMQ的消息模型核心思想是生产者不会直接向队列发送任何消息。实际上,生产者甚至不知道一个消息将传递给哪个队列。</p>
<p>事实上，生产者只能发送消息给一个exchange。exchange 很简单。一方面它接收来自生产者的消息，另一方面它把消息推送给队列。因此exchange要知道怎么处理接收到的message。是把message发给一个特定的队列?还是发给多个队列?或者丢弃？这个规则是由 exchange type 定义的。</p>
<p><img src="http://www.rabbitmq.com/img/tutorials/exchanges.png" alt=""></p>
<p>exchange 有以下几种：direct, topic, headers 和 fanout。我们主要使用最后一种——fanout。下面我们定义一个 名字叫logs,类型为fanout的exchange：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">"logs"</span>, <span class="string">"fanout"</span>);</span><br></pre></td></tr></table></figure></p>
<p>fanout exchange很简单。它会广播所有收到的message传递给它知道的queue。这正是我们需要的日志记录方式。</p>
<p><strong>Listing exchanges</strong><br>你可以在服务器上面使用rabbitmqctl命令查看所有的交换机信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rabbitmqctl list_exchanges</span><br><span class="line">Listing exchanges ...</span><br><span class="line">        direct</span><br><span class="line">amq.direct      direct</span><br><span class="line">amq.fanout      fanout</span><br><span class="line">amq.headers     headers</span><br><span class="line">amq.match       headers</span><br><span class="line">amq.rabbitmq.log        topic</span><br><span class="line">amq.rabbitmq.trace      topic</span><br><span class="line">amq.topic       topic</span><br><span class="line">logs    fanout</span><br><span class="line">...<span class="keyword">done</span>.</span><br></pre></td></tr></table></figure></p>
<p>In this list there are some amq.<em> exchanges and the default (unnamed) exchange. These are created by default, but it is unlikely you’ll need to use them at the moment.<br>这个列表信息里有一些amq.</em>开头的是默认的交换机。他们默认就被创建好了。</p>
<p><strong>Nameless exchange</strong><br>在之前章节的教程中，我们不知道exchange,但是我们仍然能够把message传递给queue，这是因为我们使用了默认的exchange。我们使用了空字符串作为交换机信息。</p>
<p>之前我们发布message，用的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"hello"</span>, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure></p>
<p>第一参数代表exchange的名字，这里使用空字符串表示用默认的或nameless exchange。如果队列存在的话，message会被发送给routingKey指定的队列。</p>
<p>接下来，我们把它替换成发布到我们命名的exchange：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish( <span class="string">"logs"</span>, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure></p>
<h2 id="Temporary-queues-临时队列"><a href="#Temporary-queues-临时队列" class="headerlink" title="Temporary queues(临时队列)"></a>Temporary queues(临时队列)</h2><p>之前我们使用的queue都有一个特定的名字（hello 或者 task_queue?）。当你想在生产者和消费者之间共享队列，给queue命名是至关重要的。</p>
<p>但是 这种情况对于我们的日志系统是不适合的。我们想看到所有的日志信息，而不是仅仅是他的一个子集。我们也只对当前流动的感兴趣而不是旧的消息。为了解决这个问题我们需要做两件事：</p>
<p>首先，我们需要一个新的，空的队列，不管什么时候我们连接到Rabbit。这就需要，我们每次连接rabbti都要创建一个名字随机的队列，或者让服务器选择一个名字随机的队列给我们。</p>
<p>其次，一旦我们consumer断开与queue的连接，queue应该自动删除。</p>
<p>在Java client 我们提供了一个无参的 queueDeclare()方法，使用它，我们可以创建一个 不持久化，名字唯一，自动删除的队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure></p>
<p>这里queueName是随机生成的队列的名字。例如amq.gen-JzTY20BRgKO-HjmUJj0wLg.</p>
<h2 id="Bindings-绑定"><a href="#Bindings-绑定" class="headerlink" title="Bindings(绑定)"></a>Bindings(绑定)</h2><p><img src="http://www.rabbitmq.com/img/tutorials/bindings.png" alt=""></p>
<p>我们已经创建了一个 fanout类型的exchange和所需的queue。现在，我们就需要告诉 exchange 发送messages 到我们指定的 queue。这里，exchange和queue的关系我们叫做binding（绑定）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, <span class="string">"logs"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure>
<p>现在这个logs exchange将把消息添加到我们指定的队列中。</p>
<p><strong>Listing bindings</strong></p>
<p>你可以通过rabbitmqctl list_bindings命令，查看已经存在的bingding。</p>
<h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>这个生产程序里，发送日志消息，和之前的教程有所区别。主要的变化是我们通过指定的logs exchange去发布消息。以前我们需要通过一个routingKey去发送，这里我们通过fanout  exchanges忽略了这个值。这里是EmitLog.java的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/EmitLog.java" target="_blank" rel="noopener">(EmitLog.java source)</a></p>
<p>正如你看到的，在建立连接后我们声明了一个交换机。这一步是必须的，禁止发布消息到一个不存在的交换机中。</p>
<p>如果交换机没有和队列进行绑定，消息将会丢失，但是这种情况是允许的；如果没有消费者监听，我们可以安全的丢弃消息。</p>
<p>ReceiveLogs.java的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/ReceiveLogs.java" target="_blank" rel="noopener">(ReceiveLogs.java source)</a></p>
<p>编译我们写的代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -cp .:rabbitmq-client.jar EmitLog.java ReceiveLogs.java</span><br></pre></td></tr></table></figure></p>
<p>如果我们想保存日志信息到文件，只需要打开控制台指定ReceiveLogs类型：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp .:rabbitmq-client.jar ReceiveLogs &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure></p>
<p>如果你想在屏幕上查看日志信息，新打开一个终端运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp .:rabbitmq-client.jar ReceiveLogs</span><br></pre></td></tr></table></figure></p>
<p>最后，发送日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp .:rabbitmq-client.jar EmitLog</span><br></pre></td></tr></table></figure></p>
<p>使用rabbitmqctl list_bindings命令可以验证创建的bindings and queues信息，有2个ReceiveLogs.java programs 运行中，你会看到这样的信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rabbitmqctl list_bindings</span><br><span class="line">Listing bindings ...</span><br><span class="line">logs    exchange        amq.gen-JzTY20BRgKO-HjmUJj0wLg  queue           []</span><br><span class="line">logs    exchange        amq.gen-vso0PVvyiRIL2WoV3i48Yg  queue           []</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure></p>
<p>结果很简单，数据从logs交换机传递给了两个队列，这正是我们想要的结果。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/15/RabbitMQ-Tutorials-WorkQueues/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/15/RabbitMQ-Tutorials-WorkQueues/" itemprop="url">
                  RabbitMQ Tutorials (Work queues)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-15 20:10:18" itemprop="dateCreated datePublished" datetime="2016-09-15T20:10:18+08:00">2016-09-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/15/RabbitMQ-Tutorials-WorkQueues/" class="leancloud_visitors" data-flag-title="RabbitMQ Tutorials (Work queues)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>(使用java客户端)<br><img src="http://www.rabbitmq.com/img/tutorials/python-two.png" alt=""><br>在第一节的教程里，我们创建了一个程序，发送和接收消息，从一个named queue(命名队列 )。本节，我们会创建一个 Work Queue(工作队列)，用来分发耗时任务给多个Workers(工人)。</p>
<p>使用Work Queues(别名：Task Queue)是为了避免立即做一个资源密集型任务,而不得不等待它完成。我们可以把这个耗时的任务封装提取起来作为message,发送给一个queue。一个Worker 后台进程会获取task,然后执行他。当有多个Workers 时，他们平分这些task。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>上一节的教程，我们发送已一条包含“Hello World”的消息。这一节我们要发送一个复杂的任务。我们不做真实的任务，采用Thread.Sleep()来模拟我们的程序很忙。我们以程序中发送的字符串的点数来作为复杂性。每一个点占用1秒的时间，比如，一个任务的内容是Hello…将会耗时三秒钟。</p>
<p>我们修改上一节的Send.java的代码,允许命令行发送任意消息，这个程序会将任务分配给我们的工作队列，我们叫它NewTask.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, <span class="string">"hello"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br></pre></td></tr></table></figure></p>
<p>从命令行获取消息信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="keyword">return</span> joinStrings(strings, <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = strings.length;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        words.append(delimiter).append(strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> words.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的Recv.java程序也必须做改变:它需要处理每个消息的内容。我们叫它Worker.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">true</span>; <span class="comment">// acknowledgment is covered below</span></span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br></pre></td></tr></table></figure></p>
<p>我们的工作任务模拟执行时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: task.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'.'</span>) Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在工作目录中编译这2个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -cp rabbitmq-client.jar NewTask.java Worker.java</span><br></pre></td></tr></table></figure></p>
<h2 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h2><p>使用Task Queue的一个优点就是可以很容易的平均分配任务。如果queue里有堆积过多的任务，我们可以添加更多的Worker就行了。规模很容易扩大。 </p>
<p>接下来，我们同时运行2个工作实例，他们将从队列中获取消息，但怎么去获取？我们一起看看。</p>
<p>你需要打开三个控制台。2个运行工作程序，这些控制台作为我们的2个消费者 - C1和C2.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell1$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">Worker</span><br><span class="line"> [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell2$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">Worker</span><br><span class="line"> [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span><br></pre></td></tr></table></figure>
<p>在第三个控制台发布新的任务。你可以发布少量的消息给消费者消费：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shell3$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">NewTask First message.</span><br><span class="line">shell3$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">NewTask Second message..</span><br><span class="line">shell3$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">NewTask Third message...</span><br><span class="line">shell3$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">NewTask Fourth message....</span><br><span class="line">shell3$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">NewTask Fifth message.....</span><br></pre></td></tr></table></figure></p>
<p>我们看看什么内容给了我们的工作者：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell1$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar</span><br><span class="line">Worker</span><br><span class="line"> [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span><br><span class="line"> [x] Received <span class="string">'First message.'</span></span><br><span class="line"> [x] Received <span class="string">'Third message...'</span></span><br><span class="line"> [x] Received <span class="string">'Fifth message.....'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell2$ java -cp .:commons-io-<span class="number">1.2</span>.jar:commons-cli-<span class="number">1.1</span>.jar:rabbitmq-client.jar</span><br><span class="line">Worker</span><br><span class="line"> [*] Waiting <span class="keyword">for</span> messages. To exit press CTRL+C</span><br><span class="line"> [x] Received <span class="string">'Second message..'</span></span><br><span class="line"> [x] Received <span class="string">'Fourth message....'</span></span><br></pre></td></tr></table></figure>
<p>默认RabbitMQ会顺序的，平均的把任务发给每个consumer,到最后每个Consumer会得到相同数量的任务。这种分配方式我们称为round-robin。可以尝试第三个或者更多的工作者。</p>
<h2 id="Message-acknowledgment"><a href="#Message-acknowledgment" class="headerlink" title="Message acknowledgment"></a>Message acknowledgment</h2><p>执行一个耗时的任务，你可能会想知道任务的执行情况。是否有Consumer开始执行任务了？是否任务执行到一半死机了？<br>当前我们上面的代码，一旦RabbitMQ分发message给Custoerm,它就会立刻从内存删除。这种情况下，如果你关闭一个Worker,我们就会丢失他正在执行的消息。同样，我们也会丢失之前分发给他，还没有来的及执行的消息。</p>
<p>但是我们不想丢失任何task。如果一个Worker死了，我们想把任务分发给其他的Worker。</p>
<p>为了确保message不丢失，RabbitMQ 提供了 message acknowledgments。Ack是consumer 发送给RabbitMQ的，告诉它，task 已经接受，并处理了，RabbitMQ 可以删除它了。</p>
<p>如果一个consumer死机了（channel closed,connection closed or Tcp connection lost），没有返回ack,RabbitMQ就会知道task 没有处理完，该task就会重新排队。如果这时候有另外一个Consumer在线，RabbitMQ 就会把它分发给他。</p>
<p>所有的消息都不会超时，当消费者挂掉后RabbitMQ将会重新发送消息，处理一条消息有可能会很长时间，但是总是能处理掉。</p>
<p>默认Message acknowLedgments 是打开的，之前的例子里我们显示的设置了autoAck=true,现在我们设置成false，一旦我们处理了一条任务，我们就发送一个正确的确认信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>); <span class="comment">// accept only one unack-ed message at a time (see below)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br></pre></td></tr></table></figure></p>
<p>运行上面的代码，如果我们使用CTRL+C kill一个worker，消息也不会被丢失，很快这个消息就会被再次投递给其他工作者。</p>
<h2 id="Forgotten-acknowledgment"><a href="#Forgotten-acknowledgment" class="headerlink" title="Forgotten acknowledgment"></a>Forgotten acknowledgment</h2><p>丢失BasicAck是很常见的错误，尽管这个错很小，但后果很严重。当Client quit,Messages 会重新分发，但是RabbitMQ 由于不能释放掉那些unacked message ,所以会消耗越来越多的内存。</p>
<p>为了 调试这种错误， 你可以使用rabbitmqctl来打印出 messages_unacknowledged 的message信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br><span class="line">Listing queues ...</span><br><span class="line">hello    0       0</span><br><span class="line">...<span class="keyword">done</span>.</span><br></pre></td></tr></table></figure></p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>通过上面的ACK配置，当consumer 死亡的时候，task 不会丢失。但是如果RabbitMQ服务停了，task 仍然会丢失。<br>这里我们就要持久化 task的信息了。</p>
<p>当RabbitMQ停止或者宕机了，如果你没有告诉它怎么处理的话，队列和消息也会丢失。需要做两步操作来确保消息不被丢失：我们需要标记队列和消息是持久化的。</p>
<p>首先，我们需要保证队列在RabbitMQ中不会丢失。我们在代码里声明持久化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"hello"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>尽管我们定义名字叫hello 队列要持久化，但是仍然不会生效。这是因为我们已经定义了一个没有持久化的名字叫hello 队列。RabbitMQ 不允许重新定义（用不同的参数）一个已经存在的队列，会报错。因此这里我们应该另外定义一个队列，<br>例如 task_queue:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"task_queue"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>queue 持久化的修改，producer 和consumer的代码都要修改.</p>
<p>通过上面的代码设置我们的queue，即使RabbitMQ重启也不会丢失。接下来，我们来持久化message。发布消息的时候提供MessageProperties.PERSISTENT_TEXT_PLAIN值即可持久化。</p>
<h2 id="消息持久化备注"><a href="#消息持久化备注" class="headerlink" title="消息持久化备注"></a>消息持久化备注</h2><p>尽管我们设置message持久化了，但是这也不能完全保证message不会丢失。<br>这是由于RabbitMQ保存message到硬盘是需要时间的，如果再此期间RabbitMQ服务挂了，message就丢失了。不过对于一般的程序已经足够了。如果要一个更强壮的方案，你可是使用<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">publisher confirms</a>.</p>
<h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>也许你已经主要到，上面代码实现的message的调度不是你想要的。例如，假设有两个Worker,所有的奇数的message都是耗时的操作，而偶数的message都是很简单的。你会发现一个Worker很空闲，而另一个Woker累死累活的。然而RabbitMQ不知道，还是不停的给他发任务。</p>
<p>这个情况的发生，是由于RabbitMQ 不看 the number of unacknowledged message，只要message进入队列就分发message。他只是盲目的分发message。<br><img src="http://www.rabbitmq.com/img/tutorials/prefetch-count.png" alt=""><br>为了解决上面的问题，我们可以使用 basicQos方法 设置 prefetchCount=1。这个设置会告诉RabbitMQ 每次给Workder只分配一个task，只有当task执行完了，才分发下一个任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure></p>
<p>NOTE:注意queue的size</p>
<p>如果所有的Worker都很忙,你的队列会填满，因此你需要监测queue的情况，添加更多的worker 或者采用其他的策略。</p>
<h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>最终的代码在我们的NewTask.java类中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">                      <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">    channel.basicPublish( <span class="string">""</span>, TASK_QUEUE_NAME,</span><br><span class="line">            MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">            message.getBytes());</span><br><span class="line">    System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/NewTask.java" target="_blank" rel="noopener">(NewTask.java source)</a><br>Worker.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="keyword">final</span> Connection connection = factory.newConnection();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          doWork(message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">          channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">    channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : task.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/Worker.java" target="_blank" rel="noopener">(Worker.java source)</a></p>
<p>使用message acknowledgments和prefetchCount可以设置一个工作队列。通过durability选项让我们的任务能够在RabbitMQ重启后也能够存在。</p>
<p>关于Channel方法和MessageProperties的更多信息，你可以浏览在线的<a href="http://www.rabbitmq.com/releases/rabbitmq-java-client/current-javadoc/" target="_blank" rel="noopener">javadocs</a>.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/11/RabbitMQ-Tutorials-HelloWorld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/11/RabbitMQ-Tutorials-HelloWorld/" itemprop="url">
                  RabbitMQ Tutorials (Hello World)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-11 22:18:18" itemprop="dateCreated datePublished" datetime="2016-09-11T22:18:18+08:00">2016-09-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/11/RabbitMQ-Tutorials-HelloWorld/" class="leancloud_visitors" data-flag-title="RabbitMQ Tutorials (Hello World)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>RabbitMQ是一个消息代理。它的核心原理非常简单：接收和发送消息。你可以把它想像成一个邮局：你把信件放入邮箱，邮递员就会把信件投递到你的收件人处。在这个比喻中，RabbitMQ是一个邮箱、邮局、邮递员。</p>
<p>RabbitMQ和邮局的主要区别是，它处理的不是纸，而是接收、存储和发送二进制的数据——消息。</p>
<p>一般提到RabbitMQ和消息，都用到一些专有名词。</p>
<ul>
<li>生产(Producing)意思就是发送。发送消息的程序就是一个生产者(producer)。我们一般用”P”来表示：<br><img src="http://www.rabbitmq.com/img/tutorials/producer.png" alt="生产"></li>
<li>队列(queue)就是邮箱的名称。消息通过你的应用程序和RabbitMQ进行传输，它们能够只存储在一个队列（queue）中。队列（queue）没有任何限制，你要存储多少消息都可以——基本上是一个无限的缓冲。多个生产者（producers）能够把消息发送给同一个队列，同样，多个消费者（consumers）也能够从一个队列（queue）中获取数据。队列可以用下图标识：<br><img src="http://www.rabbitmq.com/img/tutorials/queue.png" alt="此处输入图片的描述"></li>
<li>消费（Consuming）和获取消息是一样的意思。一个消费者（consumer）就是一个等待获取消息的程序。我们把它画作”C”：<br><img src="http://www.rabbitmq.com/img/tutorials/consumer.png" alt="消费"></li>
</ul>
<p>注意：一般生产者，消费者和代理不必部署在同一台机子上。</p>
<h2 id="“Hello-World”"><a href="#“Hello-World”" class="headerlink" title="“Hello World”"></a>“Hello World”</h2><p>(using the Java Client)<br>我们将在这个章节里创建2个java程序;一个生产者发送一条消息，一个消费者接受消息并且打印输出。我们跳过Java API的细节，从最简单的事情开始说起。通过一条 “Hello World”作为消息。</p>
<p>在下面的图表中， “P” 是我们的生产者,”C”是我们的消费者。中间是一个队列 - 作为RabbitMQ的消息缓冲区提供给消费者。<br><img src="http://www.rabbitmq.com/img/tutorials/python-one.png" alt=""></p>
<h2 id="The-Java-client-library"><a href="#The-Java-client-library" class="headerlink" title="The Java client library"></a>The Java client library</h2><p>RabbitMQ 支持多种协议。该指南使用的是AMQP 0-9-1协议，这是一个开放的，通用的消息协议。RabbitMQ 提供了<a href="http://rabbitmq.com/devtools.html" target="_blank" rel="noopener">许多客户端语言</a>的支持。我们将使用Java client 提供商。<br>下载<a href="http://www.rabbitmq.com/java-client.html" target="_blank" rel="noopener">客户端依赖包</a>,检查签名信息。解压到你的工作目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unzip rabbitmq-java-client-bin-*.zip</span><br><span class="line">$ cp rabbitmq-java-client-bin-*/*.jar ./</span><br></pre></td></tr></table></figure></p>
<p>(这个客户端你也可以从Maven的中心仓库去下载，groupId= com.rabbitmq,artifactId=amqp-client)<br>现在我们有了客户端的依赖，就可以编写一些代码了。</p>
<h2 id="Sending-发送端"><a href="#Sending-发送端" class="headerlink" title="Sending 发送端"></a>Sending 发送端</h2><p><img src="http://www.rabbitmq.com/img/tutorials/sending.png" alt=""><br>我们将执行我们的消息发送端发送给我们的消息接收端。发送者将连接到RabbitMQ，发送一条消息，然后退出。<br>在Send.java文件中，我们需要引入一些依赖：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br></pre></td></tr></table></figure></p>
<p>在类里面设置队列的名称：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们创建一个连接到服务器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br></pre></td></tr></table></figure></p>
<p>这里创建了一个Socket连接，负责协议版本协商和身份验证等等，这里由于连接的是本地机子，所以取值localhost。如果我们想连接到其他机器的代理服务，我们只需要添加IP地址就可以了。</p>
<p>接下来，创建一个channel(通道),大多数任务都是在这里完成的。</p>
<p>要发送消息，我们必须首先定义一个queue(队列)，然后我们才成把消息发送给queue:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br></pre></td></tr></table></figure></p>
<p>queue 的定义具有幂等性，如果不存在就会被创建。消息的内容是一个字节数组，所以你可以对内容进行编码。</p>
<p>最后，我们关闭通道和连接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></p>
<p>整个<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/Send.java" target="_blank" rel="noopener">Send.java</a>类在这里查看。<br>Sending doesn’t work!<br>发送端不工作的情况<br>如果你第一次使用RabbitMQ并且没有看到发送的消息，你可以不知道是什么原因导致的错误，也许是没有足够的磁盘空间(默认需要1Gb的空间).<a href="http://www.rabbitmq.com/configure.html#config-items" target="_blank" rel="noopener">配置文档</a>会告诉你怎么设置disk_free_limit。</p>
<h2 id="Receiving-接收者"><a href="#Receiving-接收者" class="headerlink" title="Receiving 接收者"></a>Receiving 接收者</h2><p>我们的接收者会从RabbitMQ拉取消息，不像发送者发送消息那样，接收端会保持监听消息，然后打印输出。<br><img src="http://www.rabbitmq.com/img/tutorials/receiving.png" alt=""><br>在Recv.java里也需要引入一些依赖：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br></pre></td></tr></table></figure></p>
<p>DefaultConsumer类实现了Consumer接口，从服务端拉取消息。</p>
<p>设置上和发送端一样；打开一个连接和一个通道，并且声明一个队列进行消费。这里要和发送端的队列保持一致。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException,</span></span><br><span class="line"><span class="function">             java.lang.InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也许你已经发现，我们在接收端也定义了hello队列。这是为了确保，如果接收端先启动的时候，队列已经存在。</p>
<p>接下来，我们就要告诉服务器来交付消息。由于推送消息是一个异步操作，因此我们使用回调函数，DefaultConsumer.handleDelivery来处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">    System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br></pre></td></tr></table></figure></p>
<p>整个<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/Recv.java" target="_blank" rel="noopener">Recv.java</a>类在这里查看。</p>
<h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>通过javac对2个文件进行编译操作:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -cp rabbitmq-client.jar Send.java Recv.java</span><br></pre></td></tr></table></figure></p>
<p>然后运行他们，你需要将rabbitmq-client.jar放到classpath下，在一个终端里运行发送端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar Send</span><br></pre></td></tr></table></figure></p>
<p>然后运行接收端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp .:commons-io-1.2.jar:commons-cli-1.1.jar:rabbitmq-client.jar Recv</span><br></pre></td></tr></table></figure></p>
<p>接收端从RabbitMQ获取消息并打印，接收端会一直保持运行，等待消息到来（使用Ctrl-C 停止运行），你可以尝试运行发送端。</p>
<p>如果你想检查这个队列，使用 rabbitmqctl list_queues.<br>hello<br>移动到<a href="http://www.rabbitmq.com/tutorials/tutorial-two-java.html" target="_blank" rel="noopener">第二章节</a>怎么构建一个简单的工作队列。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cjoop.top/2016/09/11/RabbitMQ-Install-on-Windows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈均">
      <meta itemprop="description" content="世间万物皆空。唯其空，便能包容万物。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒之道">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/11/RabbitMQ-Install-on-Windows/" itemprop="url">
                  RabbitMQ Install on Windows
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-11 17:18:18" itemprop="dateCreated datePublished" datetime="2016-09-11T17:18:18+08:00">2016-09-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-23 16:04:07" itemprop="dateModified" datetime="2018-06-23T16:04:07+08:00">2018-06-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/11/RabbitMQ-Install-on-Windows/" class="leancloud_visitors" data-flag-title="RabbitMQ Install on Windows">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务下载"><a href="#服务下载" class="headerlink" title="服务下载"></a>服务下载</h2><table>
<thead>
<tr>
<th>Description</th>
<th>Download</th>
</tr>
</thead>
<tbody>
<tr>
<td>Installer for Windows systems</td>
<td><a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5.exe" target="_blank" rel="noopener">rabbitmq-server-3.6.5.exe</a></td>
</tr>
</tbody>
</table>
<h2 id="卸载以前的版本"><a href="#卸载以前的版本" class="headerlink" title="卸载以前的版本"></a>卸载以前的版本</h2><p>如果你已经安装过Erlang VM，确保是64位的版本。</p>
<h2 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h2><p>首先，下载并运行<a href="http://www.erlang.org/download.html" target="_blank" rel="noopener">Erlang Windows</a>二进制文件。大约需要安装5分钟时间。<br>然后运行安装程序rabbitmq-server-3.6.5.exe。大约需要安装2分钟，RabbitMQ将被作为一个服务运行，提供默认配置。</p>
<h2 id="运行RabbitMQ服务"><a href="#运行RabbitMQ服务" class="headerlink" title="运行RabbitMQ服务"></a>运行RabbitMQ服务</h2><p>定制 RabbitMQ环境变量<br>　　在默认的设置环境里RabbitMQ可以运行的很好,你也可以<a href="http://www.rabbitmq.com/configure.html#customise-windows-environment" target="_blank" rel="noopener">定制RabbitMQ环境</a>或者编辑<a href="http://www.rabbitmq.com/configure.html#configuration-file" target="_blank" rel="noopener">配置</a>。<br>运行 RabbitMQ<br>　　RabbitMQ服务是自动启动.你也可以通过开始菜单提供的stop/reinstall/start去管理服务。<br>管理服务<br>　　你可以通过开始菜单连接到RabbitMQ的安装目录。在开始菜单里提供了一个cmd窗口能够快速连接到sbin目录。这里能够很方便的运行各种<a href="http://www.rabbitmq.com/manpages.html" target="_blank" rel="noopener">命令</a>。</p>
<h2 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h2><p>防火墙和一些安装工具会阻止RabbitMQ绑定的端口，这种情况下，RabbitMQ会启动失败，确保以下端口是被允许绑定的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4369 (epmd), 25672 (Erlang distribution)</span><br><span class="line">5672, 5671 (AMQP 0-9-1 without and with TLS)</span><br><span class="line">15672 (if management plugin is enabled)</span><br><span class="line">61613, 61614 (if STOMP is enabled)</span><br><span class="line">1883, 8883 (if MQTT is enabled)</span><br></pre></td></tr></table></figure></p>
<p>可以配置RabbitMQ使用其他端口。</p>
<h2 id="默认用户访问"><a href="#默认用户访问" class="headerlink" title="默认用户访问"></a>默认用户访问</h2><p>这个服务创建了一个用户名guest密码为guest的用户。没有配置的客户端将采用这个用户。默认情况下这个凭证只能用于连接本机。<br>查看文档中<a href="http://www.rabbitmq.com/access-control.html" target="_blank" rel="noopener">访问控制</a>信息。了解如何创建更多的用户、删除guest用户，或者允许guest用户进行远程访问。</p>
<h2 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h2><p>通过sbin目录的rabbitmqctl.bat可以停止服务或者检查服务的状态(作为管理员操作)。<br>停止服务<br>　　使用 rabbitmqctl stop.<br>检查服务的状态<br>　　使用 rabbitmqctl status. 得到当前服务的运行信息报告.<br>更多的命令信息查看 <a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html" target="_blank" rel="noopener">rabbitmqctl</a></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>服务器会输出一个日志文件RABBITMQ_NODENAME.log到RABBITMQ_LOG_BASE目录中，额外的日志数据会写到RABBITMQ_NODENAME-sasl.log文件中。<br>这个服务会追加到日志文件中，保留的是一个完整的日志记录。<br>你也可以通过命令rabbitmqctl rotate_logs来轮转日志。</p>
<h2 id="Troubleshooting-When-Running-as-a-Service"><a href="#Troubleshooting-When-Running-as-a-Service" class="headerlink" title="Troubleshooting When Running as a Service"></a>Troubleshooting When Running as a Service</h2><p>In the event that the Erlang VM crashes whilst RabbitMQ is running as a service, rather than writing the crash dump to the current directory (which doesn’t make sense for a service) it is written to an erl_crash.dump file in the base directory of the RabbitMQ server (set by the RABBITMQ_BASE environment variable, defaulting to %APPDATA%\%RABBITMQ_SERVICENAME% - typically %APPDATA%\RabbitMQ otherwise).</p>
<h2 id="Windows-specific-Issues"><a href="#Windows-specific-Issues" class="headerlink" title="Windows-specific Issues"></a>Windows-specific Issues</h2><p>We aim to make RabbitMQ a first-class citizen on Windows. However, sometimes there are circumstances beyond our control. Please consult the Windows-specific Issues page.</p>
<h2 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h2><p>If you have questions or need help, feel free to ask on RabbitMQ mailing list.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="陈均" />
            
              <p class="site-author-name" itemprop="name">陈均</p>
              <p class="site-description motion-element" itemprop="description">世间万物皆空。唯其空，便能包容万物。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈均</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>



  <div class="footer-custom"><a target="_blank" rel="external nofollow" href="http://www.beian.miit.gov.cn"><b>蜀ICP备17001803号</b></a></div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("X2YtjBbKwWtfKz2jH6SBGpLa-gzGzoHsz", "S6zjXgoW7l4HGNvpcJrXroPJ");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! See more at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see here how to solve it: https://github.com/theme-next/hexo-leancloud-counter-security. \n But you also can use LeanCloud without security, by set \'security\' option to \'false\'.');
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
